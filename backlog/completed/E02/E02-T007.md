---
id: E02-T007
title: Rate limiting middleware
status: done
priority: medium
labels:
  - backend
  - infrastructure
  - security
assignee: ""
workflow_state: DONE
epic: E02
agentic_style: "prescriptive"
depends_on:
  - E02-T001
blocks: []
breakpoint: false
assigned_agent: developer
created_at: 2026-01-12T00:00:00Z
updated_at: 2026-01-12T09:55:00.000Z
started_at: 2026-01-12T06:09:48.625Z
completed_at: 2026-01-12T09:55:00.000Z
spec_file: backlog/docs/specs/E02/E02-T007-spec.md
test_files:
  - apps/api/src/__tests__/middleware/rate-limit.middleware.test.ts
  - apps/api/src/__tests__/integration/rate-limit.test.ts
  - apps/api/src/__tests__/integration/auth.routes.test.ts
  - apps/api/src/__tests__/integration/oauth.routes.test.ts
code_files:
  - apps/api/src/middleware/rate-limit.middleware.ts
  - apps/api/src/server.ts
  - apps/api/src/config.ts
  - apps/api/src/routes/health.routes.ts
  - packages/core/src/errors/rate-limit.error.ts
  - packages/core/src/errors/index.ts
  - packages/core/src/errors/base.error.ts
pr_url: "https://github.com/ryandt33/raptscallions/pull/3"
---

# E02-T007: Rate limiting middleware

## Description

Implement rate limiting middleware using Redis to prevent abuse of auth endpoints and API routes. Use @fastify/rate-limit with different limits for auth routes vs general API.

## Acceptance Criteria

- [x] AC1: @fastify/rate-limit plugin installed and configured
- [x] AC2: Redis used as storage backend for rate limit counters
- [x] AC3: Auth routes limited to 5 requests per minute per IP
- [x] AC4: General API routes limited to 100 requests per minute per user
- [x] AC5: Rate limit exceeded returns 429 with Retry-After header
- [x] AC6: Anonymous users rate limited by IP address
- [x] AC7: Authenticated users rate limited by user ID
- [x] AC8: Rate limit counters reset after time window expires
- [x] AC9: Tests verify rate limits are enforced correctly
- [x] AC10: Different rate limits can be applied to specific routes

## Technical Notes

Install rate limit plugin:
```bash
pnpm add @fastify/rate-limit ioredis
```

Configure rate limiting:
```typescript
import rateLimit from '@fastify/rate-limit';
import Redis from 'ioredis';

const redis = new Redis(env.REDIS_URL);

// Global rate limit (general API)
await app.register(rateLimit, {
  max: 100,
  timeWindow: '1 minute',
  redis,
  keyGenerator: (request) => {
    // Use user ID if authenticated, otherwise IP
    return request.user?.id || request.ip;
  },
});

// Stricter limit for auth routes
app.register(async (authRoutes) => {
  await authRoutes.register(rateLimit, {
    max: 5,
    timeWindow: '1 minute',
    redis,
    keyGenerator: (request) => request.ip,
  });

  authRoutes.post('/auth/login', loginHandler);
  authRoutes.post('/auth/register', registerHandler);
});
```

Custom rate limit for specific routes:
```typescript
app.post('/expensive-operation', {
  config: {
    rateLimit: {
      max: 10,
      timeWindow: '1 hour',
    },
  },
}, async (request, reply) => {
  // ...
});
```

Error response on rate limit:
```json
{
  "error": "Too many requests",
  "code": "RATE_LIMIT_EXCEEDED",
  "details": {
    "limit": 5,
    "remaining": 0,
    "resetAt": "2026-01-12T12:34:56Z"
  }
}
```

Headers on rate-limited responses:
```
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 5
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1705065296
Retry-After: 42
```

Testing rate limits:
```typescript
it('should rate limit auth login attempts', async () => {
  const requests = Array(6).fill(null).map(() =>
    app.inject({
      method: 'POST',
      url: '/auth/login',
      payload: { email: 'test@example.com', password: 'wrong' },
    })
  );

  const responses = await Promise.all(requests);

  // First 5 should succeed (401 for wrong password)
  responses.slice(0, 5).forEach(r => {
    expect(r.statusCode).toBe(401);
  });

  // 6th should be rate limited
  expect(responses[5].statusCode).toBe(429);
  expect(responses[5].headers['retry-after']).toBeDefined();
});
```

## History

| Date       | State    | Agent   | Notes                      |
| ---------- | -------- | ------- | -------------------------- |
| 2026-01-12 | DRAFT    | pm      | Task created               |
| 2026-01-12 | ANALYZED | analyst | Specification completed    |
| 2026-01-12 | PLAN_REVIEW | designer | UX review completed - APPROVED with recommendations |
| 2026-01-12 | TESTS_READY | developer | Tests written and verified (red phase) |
| 2026-01-12 | IMPLEMENTED | developer | Implementation complete - all tests passing |
| 2026-01-12 | CODE_REVIEW | reviewer | Conditional approval - non-blocking improvements deferred |
| 2026-01-12 | IMPLEMENTED | developer | Code review fixes applied: ioredis mocks in auth/OAuth tests, context-aware error messages, health check exemption, unit tests for key generation/error builder |
| 2026-01-12 | INTEGRATION_TESTING | qa | QA passed - all 10 ACs verified, 1041/1041 tests pass |
| 2026-01-12 | DOCS_UPDATE | integration | Integration tests passed - verified against real Docker infrastructure |
| 2026-01-12 | PR_READY | writer | Documentation updated: .env.example, ARCHITECTURE.md, CONVENTIONS.md |
| 2026-01-12 | DONE | developer | PR merged manually by user |


## Reviews

### UX Review

- **Reviewer:** designer
- **Date:** 2026-01-12
- **Verdict:** APPROVED with recommendations
- **Notes:** Rate limiting spec demonstrates strong UX considerations. Two MEDIUM priority enhancements required: (1) Add user-friendly message field to error details with context-aware messaging, (2) Document school/shared IP scenarios in deployment guide. Spec balances security and usability well, with appropriate rate limits and clear error communication. Frontend recommendations provided for countdown timers and progressive disclosure.

### Plan Review

- **Reviewer:** architect
- **Date:** 2026-01-12
- **Verdict:** APPROVED WITH MINOR CHANGES
- **Notes:** Architecturally sound implementation spec. Three required changes: (1) Reuse existing Redis connection instead of creating new client, (2) Clarify middleware registration order relative to error handler, (3) Explicitly exempt health check endpoints from rate limiting. Excellent alignment with technology stack, security best practices, and distributed systems design. Ready for implementation after applying required changes.

### Code Review

- **Reviewer:** reviewer
- **Date:** 2026-01-12
- **Verdict:** CONDITIONAL APPROVAL
- **Notes:** Core rate limiting functionality working correctly. 11/11 rate-limit integration tests pass. Remaining issues (shared Redis, context-aware messages, health check exemption) are non-blocking improvements recommended for follow-up task. Failing auth/OAuth tests are a test isolation issue, not implementation defect.

### QA Review

- **Reviewer:** qa
- **Date:** 2026-01-12
- **Verdict:** PASSED
- **Notes:** All 10 acceptance criteria verified with comprehensive evidence. Tests pass (1041/1041), typecheck passes, build succeeds. Implementation is production-ready with proper dual-tier rate limiting, context-aware error messages, and health check exemption. See [QA Report](backlog/docs/reviews/E02/E02-T007-qa-report.md) for full details.

### Integration Test

- **Reviewer:** integration (automated)
- **Date:** 2026-01-12
- **Verdict:** PASSED
- **Notes:** All 10 acceptance criteria verified against real Docker infrastructure (postgres:16, redis:7, api). Rate limiting correctly enforced with Redis backend, proper headers on responses, 429 errors with Retry-After header, health endpoint exemption working, and different IPs have independent rate limit buckets. See [Integration Report](backlog/docs/reviews/E02/E02-T007-integration-report.md) for full details.

## Documentation Updates

The following documentation was updated to reflect the rate limiting implementation:

### Files Updated

1. **[.env.example](.env.example)** - Added rate limiting configuration section:
   - `RATE_LIMIT_API_MAX` - Max requests per minute for API routes (default: 100)
   - `RATE_LIMIT_AUTH_MAX` - Max requests per minute for auth routes (default: 5)
   - `RATE_LIMIT_TIME_WINDOW` - Time window for rate limits (default: "1 minute")

2. **[docs/ARCHITECTURE.md](docs/ARCHITECTURE.md)** - Added Rate Limiting section under Authentication & Authorization:
   - Rate limit tiers (Auth: 5 req/min, API: 100 req/min)
   - Key generation strategies (user-based vs IP-based)
   - Configuration environment variables
   - Error response format with context-aware messaging
   - Response headers documentation
   - Custom route limit examples
   - File locations

3. **[docs/CONVENTIONS.md](docs/CONVENTIONS.md)** - Updated Error Handling section:
   - Added `RATE_LIMIT_EXCEEDED` and `FORBIDDEN` to ErrorCode enum
   - Added `RateLimitError` class documentation
   - Added `ForbiddenError` class documentation

### Key Documentation Points

- **Two-tier rate limiting**: Auth routes (5 req/min per IP) vs API routes (100 req/min per user)
- **Redis backend**: Distributed rate limiting for horizontal scaling
- **Context-aware errors**: Different messages for auth vs API rate limits
- **Health check exemption**: `/health` and `/ready` endpoints exempt from rate limiting
- **Custom route limits**: Routes can override or disable rate limiting via config

## Pull Request

- **PR**: [#3](https://github.com/ryandt33/raptscallions/pull/3)
- **Branch**: `feature/E02-T007-rate-limiting`
- **Status**: Merged
- **Merged**: 2026-01-12
