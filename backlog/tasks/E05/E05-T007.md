---
id: "E05-T007"
title: "File upload API routes"
status: "todo"
priority: "critical"
labels: [backend, api, multipart]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: ["E05-T006"]
blocks: ["E05-T009"]
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T007: File upload API routes

## Description

Implement multipart file upload route using @fastify/multipart with file size middleware, quota validation, and proper error responses following REST conventions.

## Acceptance Criteria

### Multipart Plugin Setup
- [ ] AC1: Register @fastify/multipart plugin in apps/api/src/server.ts
- [ ] AC2: Configure file size limit from storageConfig.DEFAULT_MAX_FILE_SIZE_BYTES
- [ ] AC3: Configure max files per request: 1 (single file uploads only)
- [ ] AC4: Configure allowed MIME types via plugin options

### POST /files Route
- [ ] AC5: POST /files accepts multipart/form-data
- [ ] AC6: Authentication required (app.authenticate preHandler)
- [ ] AC7: Request fields: file (binary), groupId (optional), entityType (optional), entityId (optional)
- [ ] AC8: Validates request body with Zod schema
- [ ] AC9: Calls fileService.uploadFile() with user from request.user
- [ ] AC10: Returns 201 Created with file metadata (id, name, size, mimeType, createdAt)
- [ ] AC11: Returns 400 Bad Request if no file provided
- [ ] AC12: Returns 413 Payload Too Large if file exceeds size limit
- [ ] AC13: Returns 422 Unprocessable Entity if quota exceeded
- [ ] AC14: Returns 403 Forbidden if user lacks permission

### Validation Schemas
- [ ] AC15: uploadFileBodySchema validates groupId, entityType, entityId
- [ ] AC16: entityType enum: 'avatar', 'assignment_attachment', 'submission_file'
- [ ] AC17: All fields optional except file itself

### Error Handling
- [ ] AC18: QuotaExceededError → 422 with quota details in response
- [ ] AC19: ValidationError → 400 with error details
- [ ] AC20: ForbiddenError → 403 with permission message
- [ ] AC21: StorageError → 500 with generic error message (no internal details)

### Integration Tests
- [ ] AC22: Test successful file upload returns 201 with metadata
- [ ] AC23: Test upload without authentication returns 401
- [ ] AC24: Test upload exceeding file size limit returns 413
- [ ] AC25: Test upload exceeding quota returns 422 with quota info
- [ ] AC26: Test upload with invalid MIME type returns 400
- [ ] AC27: Test upload without file returns 400
- [ ] AC28: Test upload to group without permission returns 403

## Technical Notes

### Route Implementation

```typescript
// apps/api/src/routes/files.routes.ts

import type { FastifyPluginAsync } from 'fastify';
import type { ZodTypeProvider } from 'fastify-type-provider-zod';
import { z } from 'zod';
import { FileService } from '../services/file.service.js';
import { QuotaExceededError } from '@raptscallions/storage';

const fileService = new FileService();

const uploadFileBodySchema = z.object({
  groupId: z.string().uuid().optional(),
  entityType: z.enum(['avatar', 'assignment_attachment', 'submission_file']).optional(),
  entityId: z.string().uuid().optional(),
});

export const filesRoutes: FastifyPluginAsync = async (app) => {
  const typedApp = app.withTypeProvider<ZodTypeProvider>();

  /**
   * POST /files
   * Upload a file (multipart form data)
   */
  typedApp.post(
    '/',
    {
      preHandler: [app.authenticate],
      schema: {
        consumes: ['multipart/form-data'],
        description: 'Upload a file',
        tags: ['files'],
      },
    },
    async (request, reply) => {
      // Get uploaded file
      const data = await request.file();

      if (!data) {
        return reply.status(400).send({
          error: 'No file uploaded',
          code: 'VALIDATION_ERROR',
        });
      }

      // Parse form fields
      const formData: any = {};
      for (const [key, field] of Object.entries(data.fields)) {
        formData[key] = (field as any).value;
      }

      // Validate form data
      const body = uploadFileBodySchema.parse(formData);

      // Convert file to buffer
      const buffer = await data.toBuffer();

      try {
        // Upload file
        const file = await fileService.uploadFile(
          {
            buffer,
            filename: data.filename,
            mimeType: data.mimetype,
            userId: request.user!.id,
            groupId: body.groupId,
            entityType: body.entityType,
            entityId: body.entityId,
          },
          request.ability
        );

        return reply.status(201).send({
          data: {
            id: file.id,
            name: file.name,
            mimeType: file.mimeType,
            sizeBytes: file.sizeBytes,
            entityType: file.entityType,
            entityId: file.entityId,
            createdAt: file.createdAt,
          },
        });
      } catch (error) {
        if (error instanceof QuotaExceededError) {
          return reply.status(422).send({
            error: error.message,
            code: 'QUOTA_EXCEEDED',
            details: error.details,
          });
        }
        throw error;
      }
    }
  );
};
```

### Plugin Registration

```typescript
// apps/api/src/server.ts

import multipart from '@fastify/multipart';
import { storageConfig } from '@raptscallions/storage';

export async function createServer() {
  const app = fastify({ /* ... */ });

  // Register multipart plugin for file uploads
  await app.register(multipart, {
    limits: {
      fileSize: storageConfig.DEFAULT_MAX_FILE_SIZE_BYTES,
      files: 1, // Single file per request
      fields: 10, // Max form fields
    },
    attachFieldsToBody: false, // We'll handle fields manually
  });

  // ... other plugins

  // Register routes
  await app.register(filesRoutes, { prefix: '/files' });

  return app;
}
```

### Integration Test Examples

```typescript
// apps/api/src/__tests__/routes/files.routes.test.ts

import { describe, it, expect, beforeEach } from 'vitest';
import { createTestServer } from '../helpers/test-server.js';
import FormData from 'form-data';
import fs from 'fs';

describe('POST /files', () => {
  let app: any;
  let userToken: string;

  beforeEach(async () => {
    app = await createTestServer();
    const { token } = await loginAsUser(app);
    userToken = token;
  });

  it('should upload file successfully', async () => {
    const form = new FormData();
    form.append('file', fs.createReadStream('./test-fixtures/test-file.pdf'));
    form.append('entityType', 'avatar');

    const response = await app.inject({
      method: 'POST',
      url: '/files',
      headers: {
        authorization: `Bearer ${userToken}`,
        ...form.getHeaders(),
      },
      payload: form,
    });

    expect(response.statusCode).toBe(201);
    expect(response.json().data).toHaveProperty('id');
    expect(response.json().data.name).toBe('test-file.pdf');
    expect(response.json().data.mimeType).toBe('application/pdf');
  });

  it('should return 401 without authentication', async () => {
    const form = new FormData();
    form.append('file', fs.createReadStream('./test-fixtures/test-file.pdf'));

    const response = await app.inject({
      method: 'POST',
      url: '/files',
      headers: form.getHeaders(),
      payload: form,
    });

    expect(response.statusCode).toBe(401);
  });

  it('should return 413 if file exceeds size limit', async () => {
    // Create a 20MB file (exceeds 10MB default limit)
    const largeBuffer = Buffer.alloc(20 * 1024 * 1024);
    const form = new FormData();
    form.append('file', largeBuffer, 'large-file.bin');

    const response = await app.inject({
      method: 'POST',
      url: '/files',
      headers: {
        authorization: `Bearer ${userToken}`,
        ...form.getHeaders(),
      },
      payload: form,
    });

    expect(response.statusCode).toBe(413);
  });

  it('should return 422 if quota exceeded', async () => {
    // Set user's quota to nearly full
    await setUserQuota(userId, { used: 995 * MB, limit: 1 * GB });

    // Try to upload 10MB file (would exceed quota)
    const form = new FormData();
    form.append('file', Buffer.alloc(10 * MB), 'file.pdf');

    const response = await app.inject({
      method: 'POST',
      url: '/files',
      headers: {
        authorization: `Bearer ${userToken}`,
        ...form.getHeaders(),
      },
      payload: form,
    });

    expect(response.statusCode).toBe(422);
    expect(response.json().code).toBe('QUOTA_EXCEEDED');
  });

  it('should return 400 if no file provided', async () => {
    const form = new FormData();
    form.append('entityType', 'avatar');

    const response = await app.inject({
      method: 'POST',
      url: '/files',
      headers: {
        authorization: `Bearer ${userToken}`,
        ...form.getHeaders(),
      },
      payload: form,
    });

    expect(response.statusCode).toBe(400);
    expect(response.json().error).toContain('No file uploaded');
  });

  it('should return 403 if user lacks permission', async () => {
    const form = new FormData();
    form.append('file', fs.createReadStream('./test-fixtures/test-file.pdf'));
    form.append('groupId', 'other-group-id'); // Group user doesn't belong to

    const response = await app.inject({
      method: 'POST',
      url: '/files',
      headers: {
        authorization: `Bearer ${userToken}`,
        ...form.getHeaders(),
      },
      payload: form,
    });

    expect(response.statusCode).toBe(403);
  });
});
```

## Out of Scope

- File download routes (E05-T008)
- Limit management routes (E05-T008)
- Avatar association logic (E05-T009)
- Batch/bulk uploads
- Progress tracking for large uploads
- Resumable uploads

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
