---
id: "E05-T005"
title: "Cloud storage implementations (Azure, GCS, Aliyun)"
status: "todo"
priority: "medium"
labels: [backend, storage, cloud]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: ["E05-T002"]
blocks: []
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T005: Cloud storage implementations (Azure, GCS, Aliyun)

## Description

Implement Azure Blob Storage, Google Cloud Storage, and Aliyun OSS backend adapters, providing multi-cloud support for international deployments and cloud-agnostic architecture.

## Acceptance Criteria

### Azure Blob Storage Backend
- [ ] AC1: AzureBlobStorageBackend implements IStorageBackend
- [ ] AC2: Uses @azure/storage-blob SDK
- [ ] AC3: Configuration: AZURE_STORAGE_ACCOUNT, AZURE_STORAGE_KEY, AZURE_CONTAINER
- [ ] AC4: upload() uses BlockBlobClient.upload()
- [ ] AC5: download() uses BlockBlobClient.download() with streaming
- [ ] AC6: delete() uses BlockBlobClient.delete()
- [ ] AC7: exists() uses BlockBlobClient.exists()
- [ ] AC8: getSignedUrl() generates SAS token with expiration
- [ ] AC9: Storage key format: {groupId}/{year}/{month}/{uuid}.{ext}

### Google Cloud Storage Backend
- [ ] AC10: GcsStorageBackend implements IStorageBackend
- [ ] AC11: Uses @google-cloud/storage SDK
- [ ] AC12: Configuration: GCS_PROJECT_ID, GCS_BUCKET, GCS_CREDENTIALS_PATH
- [ ] AC13: upload() uses bucket.file().save()
- [ ] AC14: download() uses bucket.file().download()
- [ ] AC15: delete() uses bucket.file().delete()
- [ ] AC16: exists() uses bucket.file().exists()
- [ ] AC17: getSignedUrl() generates v4 signed URL
- [ ] AC18: Supports application default credentials or key file

### Aliyun OSS Backend
- [ ] AC19: AliyunOssBackend implements IStorageBackend
- [ ] AC20: Uses ali-oss SDK
- [ ] AC21: Configuration: ALIYUN_REGION, ALIYUN_ACCESS_KEY_ID, ALIYUN_ACCESS_KEY_SECRET, ALIYUN_BUCKET
- [ ] AC22: upload() uses client.put()
- [ ] AC23: download() uses client.get() with buffer return
- [ ] AC24: delete() uses client.delete()
- [ ] AC25: exists() uses client.head() (catch 404)
- [ ] AC26: getSignedUrl() generates signed URL with expiration
- [ ] AC27: Supports internal/external endpoints

### Shared Testing Infrastructure
- [ ] AC28: IStorageBackendTestSuite runs against all backends
- [ ] AC29: Mock implementations for unit tests
- [ ] AC30: Integration tests skippable if credentials not available
- [ ] AC31: Test file cleanup after tests complete
- [ ] AC32: Tests verify signed URL expiration
- [ ] AC33: Tests verify error handling (network failures, auth errors)
- [ ] AC34: Test coverage >80% for each backend

### Configuration Validation
- [ ] AC35: Zod schema validates Azure config when backend=azure
- [ ] AC36: Zod schema validates GCS config when backend=gcs
- [ ] AC37: Zod schema validates Aliyun config when backend=aliyun
- [ ] AC38: Clear error messages if required env vars missing
- [ ] AC39: Environment variable documentation in README

## Technical Notes

### Azure Blob Storage Implementation

```typescript
// packages/storage/src/backends/azure.backend.ts

import { BlobServiceClient, generateBlobSASQueryParameters, BlobSASPermissions, StorageSharedKeyCredential } from '@azure/storage-blob';
import { v4 as uuidv4 } from 'uuid';
import type {
  IStorageBackend,
  UploadParams,
  UploadResult,
  SignedUrl,
} from '../types.js';
import { StorageError, NotFoundError } from '../errors.js';
import { storageConfig } from '../config.js';
import { logger } from '@raptscallions/telemetry';

export class AzureBlobStorageBackend implements IStorageBackend {
  readonly name = 'azure';
  private containerClient: any;
  private sharedKeyCredential: StorageSharedKeyCredential;

  constructor() {
    const account = storageConfig.AZURE_STORAGE_ACCOUNT;
    const key = storageConfig.AZURE_STORAGE_KEY;
    const container = storageConfig.AZURE_CONTAINER;

    this.sharedKeyCredential = new StorageSharedKeyCredential(account, key);

    const blobServiceClient = new BlobServiceClient(
      `https://${account}.blob.core.windows.net`,
      this.sharedKeyCredential
    );

    this.containerClient = blobServiceClient.getContainerClient(container);
  }

  async upload(params: UploadParams): Promise<UploadResult> {
    const storageKey = this.generateStorageKey(params);
    const blockBlobClient = this.containerClient.getBlockBlobClient(storageKey);

    try {
      await blockBlobClient.upload(params.buffer, params.buffer.length, {
        blobHTTPHeaders: {
          blobContentType: params.mimeType,
        },
      });

      logger.info({ storageKey, sizeBytes: params.buffer.length }, 'File uploaded to Azure Blob Storage');

      return {
        storageKey,
        sizeBytes: params.buffer.length,
      };
    } catch (error) {
      logger.error({ error, storageKey }, 'Failed to upload file to Azure');
      throw new StorageError(`Failed to upload file: ${(error as Error).message}`, { storageKey });
    }
  }

  async download(storageKey: string): Promise<Buffer> {
    const blockBlobClient = this.containerClient.getBlockBlobClient(storageKey);

    try {
      const downloadResponse = await blockBlobClient.download();
      const chunks: Buffer[] = [];

      for await (const chunk of downloadResponse.readableStreamBody!) {
        chunks.push(Buffer.from(chunk));
      }

      const buffer = Buffer.concat(chunks);
      logger.debug({ storageKey, sizeBytes: buffer.length }, 'File downloaded from Azure');

      return buffer;
    } catch (error: any) {
      if (error.statusCode === 404) {
        throw new NotFoundError('File', storageKey);
      }

      logger.error({ error, storageKey }, 'Failed to download file from Azure');
      throw new StorageError(`Failed to download file: ${error.message}`, { storageKey });
    }
  }

  async delete(storageKey: string): Promise<void> {
    const blockBlobClient = this.containerClient.getBlockBlobClient(storageKey);

    try {
      await blockBlobClient.delete();
      logger.info({ storageKey }, 'File deleted from Azure');
    } catch (error: any) {
      if (error.statusCode === 404) {
        return; // Already deleted
      }

      logger.error({ error, storageKey }, 'Failed to delete file from Azure');
      throw new StorageError(`Failed to delete file: ${error.message}`, { storageKey });
    }
  }

  async exists(storageKey: string): Promise<boolean> {
    const blockBlobClient = this.containerClient.getBlockBlobClient(storageKey);

    try {
      await blockBlobClient.exists();
      return true;
    } catch {
      return false;
    }
  }

  async getSignedUrl(storageKey: string, expiresIn: number = 900): Promise<SignedUrl> {
    const blockBlobClient = this.containerClient.getBlockBlobClient(storageKey);
    const expiresAt = new Date(Date.now() + expiresIn * 1000);

    try {
      const sasToken = generateBlobSASQueryParameters(
        {
          containerName: this.containerClient.containerName,
          blobName: storageKey,
          permissions: BlobSASPermissions.parse('r'), // Read only
          expiresOn: expiresAt,
        },
        this.sharedKeyCredential
      ).toString();

      const url = `${blockBlobClient.url}?${sasToken}`;

      return { url, expiresAt };
    } catch (error) {
      logger.error({ error, storageKey }, 'Failed to generate Azure SAS URL');
      throw new StorageError(`Failed to generate signed URL: ${(error as Error).message}`, { storageKey });
    }
  }

  private generateStorageKey(params: UploadParams): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const uuid = uuidv4();
    const ext = params.filename.split('.').pop() || '';
    const groupPath = params.groupId || 'system';

    return `${groupPath}/${year}/${month}/${uuid}.${ext}`;
  }
}
```

### Google Cloud Storage Implementation

```typescript
// packages/storage/src/backends/gcs.backend.ts

import { Storage } from '@google-cloud/storage';
import { v4 as uuidv4 } from 'uuid';
import type {
  IStorageBackend,
  UploadParams,
  UploadResult,
  SignedUrl,
} from '../types.js';
import { StorageError, NotFoundError } from '../errors.js';
import { storageConfig } from '../config.js';
import { logger } from '@raptscallions/telemetry';

export class GcsStorageBackend implements IStorageBackend {
  readonly name = 'gcs';
  private storage: Storage;
  private bucket: any;

  constructor() {
    this.storage = new Storage({
      projectId: storageConfig.GCS_PROJECT_ID,
      keyFilename: storageConfig.GCS_CREDENTIALS_PATH,
    });

    this.bucket = this.storage.bucket(storageConfig.GCS_BUCKET);
  }

  async upload(params: UploadParams): Promise<UploadResult> {
    const storageKey = this.generateStorageKey(params);
    const file = this.bucket.file(storageKey);

    try {
      await file.save(params.buffer, {
        metadata: {
          contentType: params.mimeType,
        },
      });

      logger.info({ storageKey, sizeBytes: params.buffer.length }, 'File uploaded to GCS');

      return {
        storageKey,
        sizeBytes: params.buffer.length,
      };
    } catch (error) {
      logger.error({ error, storageKey }, 'Failed to upload file to GCS');
      throw new StorageError(`Failed to upload file: ${(error as Error).message}`, { storageKey });
    }
  }

  async download(storageKey: string): Promise<Buffer> {
    const file = this.bucket.file(storageKey);

    try {
      const [buffer] = await file.download();
      logger.debug({ storageKey, sizeBytes: buffer.length }, 'File downloaded from GCS');

      return buffer;
    } catch (error: any) {
      if (error.code === 404) {
        throw new NotFoundError('File', storageKey);
      }

      logger.error({ error, storageKey }, 'Failed to download file from GCS');
      throw new StorageError(`Failed to download file: ${error.message}`, { storageKey });
    }
  }

  async delete(storageKey: string): Promise<void> {
    const file = this.bucket.file(storageKey);

    try {
      await file.delete();
      logger.info({ storageKey }, 'File deleted from GCS');
    } catch (error: any) {
      if (error.code === 404) {
        return; // Already deleted
      }

      logger.error({ error, storageKey }, 'Failed to delete file from GCS');
      throw new StorageError(`Failed to delete file: ${error.message}`, { storageKey });
    }
  }

  async exists(storageKey: string): Promise<boolean> {
    const file = this.bucket.file(storageKey);

    try {
      const [exists] = await file.exists();
      return exists;
    } catch {
      return false;
    }
  }

  async getSignedUrl(storageKey: string, expiresIn: number = 900): Promise<SignedUrl> {
    const file = this.bucket.file(storageKey);
    const expiresAt = new Date(Date.now() + expiresIn * 1000);

    try {
      const [url] = await file.getSignedUrl({
        version: 'v4',
        action: 'read',
        expires: expiresAt,
      });

      return { url, expiresAt };
    } catch (error) {
      logger.error({ error, storageKey }, 'Failed to generate GCS signed URL');
      throw new StorageError(`Failed to generate signed URL: ${(error as Error).message}`, { storageKey });
    }
  }

  private generateStorageKey(params: UploadParams): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const uuid = uuidv4();
    const ext = params.filename.split('.').pop() || '';
    const groupPath = params.groupId || 'system';

    return `${groupPath}/${year}/${month}/${uuid}.${ext}`;
  }
}
```

### Aliyun OSS Implementation

```typescript
// packages/storage/src/backends/aliyun.backend.ts

import OSS from 'ali-oss';
import { v4 as uuidv4 } from 'uuid';
import type {
  IStorageBackend,
  UploadParams,
  UploadResult,
  SignedUrl,
} from '../types.js';
import { StorageError, NotFoundError } from '../errors.js';
import { storageConfig } from '../config.js';
import { logger } from '@raptscallions/telemetry';

export class AliyunOssBackend implements IStorageBackend {
  readonly name = 'aliyun';
  private client: OSS;

  constructor() {
    this.client = new OSS({
      region: storageConfig.ALIYUN_REGION,
      accessKeyId: storageConfig.ALIYUN_ACCESS_KEY_ID,
      accessKeySecret: storageConfig.ALIYUN_ACCESS_KEY_SECRET,
      bucket: storageConfig.ALIYUN_BUCKET,
    });
  }

  async upload(params: UploadParams): Promise<UploadResult> {
    const storageKey = this.generateStorageKey(params);

    try {
      await this.client.put(storageKey, params.buffer, {
        headers: {
          'Content-Type': params.mimeType,
        },
      });

      logger.info({ storageKey, sizeBytes: params.buffer.length }, 'File uploaded to Aliyun OSS');

      return {
        storageKey,
        sizeBytes: params.buffer.length,
      };
    } catch (error) {
      logger.error({ error, storageKey }, 'Failed to upload file to Aliyun OSS');
      throw new StorageError(`Failed to upload file: ${(error as Error).message}`, { storageKey });
    }
  }

  async download(storageKey: string): Promise<Buffer> {
    try {
      const result = await this.client.get(storageKey);
      const buffer = Buffer.from(result.content);

      logger.debug({ storageKey, sizeBytes: buffer.length }, 'File downloaded from Aliyun OSS');

      return buffer;
    } catch (error: any) {
      if (error.code === 'NoSuchKey') {
        throw new NotFoundError('File', storageKey);
      }

      logger.error({ error, storageKey }, 'Failed to download file from Aliyun OSS');
      throw new StorageError(`Failed to download file: ${error.message}`, { storageKey });
    }
  }

  async delete(storageKey: string): Promise<void> {
    try {
      await this.client.delete(storageKey);
      logger.info({ storageKey }, 'File deleted from Aliyun OSS');
    } catch (error: any) {
      if (error.code === 'NoSuchKey') {
        return; // Already deleted
      }

      logger.error({ error, storageKey }, 'Failed to delete file from Aliyun OSS');
      throw new StorageError(`Failed to delete file: ${error.message}`, { storageKey });
    }
  }

  async exists(storageKey: string): Promise<boolean> {
    try {
      await this.client.head(storageKey);
      return true;
    } catch (error: any) {
      if (error.code === 'NoSuchKey') {
        return false;
      }
      throw error;
    }
  }

  async getSignedUrl(storageKey: string, expiresIn: number = 900): Promise<SignedUrl> {
    const expiresAt = new Date(Date.now() + expiresIn * 1000);

    try {
      const url = this.client.signatureUrl(storageKey, {
        expires: expiresIn,
        method: 'GET',
      });

      return { url, expiresAt };
    } catch (error) {
      logger.error({ error, storageKey }, 'Failed to generate Aliyun signed URL');
      throw new StorageError(`Failed to generate signed URL: ${(error as Error).message}`, { storageKey });
    }
  }

  private generateStorageKey(params: UploadParams): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const uuid = uuidv4();
    const ext = params.filename.split('.').pop() || '';
    const groupPath = params.groupId || 'system';

    return `${groupPath}/${year}/${month}/${uuid}.${ext}`;
  }
}
```

### Configuration Schema Updates

```typescript
// packages/storage/src/config.ts (additions)

export const storageConfigSchema = z.object({
  STORAGE_BACKEND: storageBackendEnum.default('s3'),

  // ... existing S3 and local configs

  // Azure Blob Storage
  AZURE_STORAGE_ACCOUNT: z.string().optional(),
  AZURE_STORAGE_KEY: z.string().optional(),
  AZURE_CONTAINER: z.string().optional(),

  // Google Cloud Storage
  GCS_PROJECT_ID: z.string().optional(),
  GCS_BUCKET: z.string().optional(),
  GCS_CREDENTIALS_PATH: z.string().optional(),

  // Aliyun OSS
  ALIYUN_REGION: z.string().optional(),
  ALIYUN_ACCESS_KEY_ID: z.string().optional(),
  ALIYUN_ACCESS_KEY_SECRET: z.string().optional(),
  ALIYUN_BUCKET: z.string().optional(),
}).refine((data) => {
  // Validate Azure config if azure backend
  if (data.STORAGE_BACKEND === 'azure') {
    return !!(
      data.AZURE_STORAGE_ACCOUNT &&
      data.AZURE_STORAGE_KEY &&
      data.AZURE_CONTAINER
    );
  }

  // Validate GCS config if gcs backend
  if (data.STORAGE_BACKEND === 'gcs') {
    return !!(
      data.GCS_PROJECT_ID &&
      data.GCS_BUCKET &&
      data.GCS_CREDENTIALS_PATH
    );
  }

  // Validate Aliyun config if aliyun backend
  if (data.STORAGE_BACKEND === 'aliyun') {
    return !!(
      data.ALIYUN_REGION &&
      data.ALIYUN_ACCESS_KEY_ID &&
      data.ALIYUN_ACCESS_KEY_SECRET &&
      data.ALIYUN_BUCKET
    );
  }

  return true;
}, {
  message: 'Required configuration missing for selected storage backend',
});
```

### Shared Test Suite

```typescript
// packages/storage/src/backends/__tests__/backend.test-suite.ts

import { describe, it, expect } from 'vitest';
import type { IStorageBackend, UploadParams } from '../../types.js';

/**
 * Shared test suite that all storage backends must pass
 */
export function runStorageBackendTests(
  createBackend: () => IStorageBackend,
  skip: boolean = false
) {
  const testSuite = skip ? describe.skip : describe;

  testSuite('IStorageBackend compliance', () => {
    let backend: IStorageBackend;

    beforeEach(() => {
      backend = createBackend();
    });

    describe('upload', () => {
      it('should upload file and return storage key', async () => {
        const params: UploadParams = {
          buffer: Buffer.from('test content'),
          filename: 'test.txt',
          mimeType: 'text/plain',
          userId: 'user-123',
          groupId: 'group-456',
        };

        const result = await backend.upload(params);

        expect(result.storageKey).toBeTruthy();
        expect(result.sizeBytes).toBe(params.buffer.length);
      });
    });

    describe('download', () => {
      it('should download uploaded file', async () => {
        const originalBuffer = Buffer.from('test content');
        const { storageKey } = await backend.upload({
          buffer: originalBuffer,
          filename: 'test.txt',
          mimeType: 'text/plain',
          userId: 'user-123',
        });

        const downloadedBuffer = await backend.download(storageKey);

        expect(downloadedBuffer.toString()).toBe(originalBuffer.toString());
      });

      it('should throw NotFoundError for non-existent file', async () => {
        await expect(
          backend.download('nonexistent/file.txt')
        ).rejects.toThrow(NotFoundError);
      });
    });

    describe('exists', () => {
      it('should return true for existing file', async () => {
        const { storageKey } = await backend.upload({
          buffer: Buffer.from('test'),
          filename: 'test.txt',
          mimeType: 'text/plain',
          userId: 'user-123',
        });

        const exists = await backend.exists(storageKey);
        expect(exists).toBe(true);
      });

      it('should return false for non-existing file', async () => {
        const exists = await backend.exists('nonexistent/file.txt');
        expect(exists).toBe(false);
      });
    });

    describe('delete', () => {
      it('should delete uploaded file', async () => {
        const { storageKey } = await backend.upload({
          buffer: Buffer.from('test'),
          filename: 'test.txt',
          mimeType: 'text/plain',
          userId: 'user-123',
        });

        await backend.delete(storageKey);

        const exists = await backend.exists(storageKey);
        expect(exists).toBe(false);
      });
    });

    describe('getSignedUrl', () => {
      it('should generate signed URL with expiration', async () => {
        const { storageKey } = await backend.upload({
          buffer: Buffer.from('test'),
          filename: 'test.txt',
          mimeType: 'text/plain',
          userId: 'user-123',
        });

        const { url, expiresAt } = await backend.getSignedUrl(storageKey, 900);

        expect(url).toBeTruthy();
        expect(expiresAt.getTime()).toBeGreaterThan(Date.now());
      });
    });
  });
}
```

### Backend-Specific Tests

```typescript
// packages/storage/src/backends/__tests__/azure.backend.test.ts

import { AzureBlobStorageBackend } from '../azure.backend.js';
import { runStorageBackendTests } from './backend.test-suite.js';

const hasAzureCredentials = !!(
  process.env.AZURE_STORAGE_ACCOUNT &&
  process.env.AZURE_STORAGE_KEY &&
  process.env.AZURE_CONTAINER
);

runStorageBackendTests(
  () => new AzureBlobStorageBackend(),
  !hasAzureCredentials // Skip if no credentials
);
```

## Out of Scope

- Multi-region replication
- CDN integration
- Cross-cloud migration tools
- Cost optimization recommendations
- Bandwidth throttling
- Storage analytics/metrics
- Object lifecycle policies
- Encryption at rest configuration

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
