---
id: "E05-T006"
title: "File service with three-tier limits and quotas"
status: "todo"
priority: "critical"
labels: [backend, service, business-logic]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: ["E05-T001", "E05-T003"]
blocks: ["E05-T007", "E05-T008"]
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T006: File service with three-tier limits and quotas

## Description

Implement FileService with three-tier limit resolution (system defaults → role-based → user overrides), quota tracking with atomic updates, CASL permission checks, and file lifecycle management (upload, download, delete).

## Acceptance Criteria

### FileLimitsService
- [ ] AC1: FileLimitsService class with getEffectiveLimits(userId) method
- [ ] AC2: Limit resolution follows priority: user override → group role → system default
- [ ] AC3: Returns limit with source indicator ('user_override', 'role_based', 'system_default')
- [ ] AC4: setUserOverride(userId, limits, setBy, reason) method for admin management
- [ ] AC5: clearUserOverride(userId) method to remove override
- [ ] AC6: getUserOverrideHistory(userId) returns audit trail

### FileService - Upload
- [ ] AC7: uploadFile(params, ability) validates file size against effective limit
- [ ] AC8: Checks quota availability BEFORE upload (fail fast)
- [ ] AC9: CASL permission check: user can upload to specified group
- [ ] AC10: MIME type validation against whitelist
- [ ] AC11: Transaction: upload to storage → insert DB record → update quota atomically
- [ ] AC12: Quota update uses SQL increment (atomic, no race conditions)
- [ ] AC13: Returns File record with metadata

### FileService - Download
- [ ] AC14: getFile(fileId, ability) retrieves file with permission check
- [ ] AC15: CASL permission check: user can read file
- [ ] AC16: Generates signed URL via storage backend
- [ ] AC17: Returns file metadata + signed URL
- [ ] AC18: Excludes soft-deleted files

### FileService - Delete
- [ ] AC19: softDeleteFile(fileId, ability) sets status='soft_deleted', deleted_at
- [ ] AC20: CASL permission check: user can delete file
- [ ] AC21: Updates quota (decrement used_bytes) atomically
- [ ] AC22: Does NOT delete from storage backend immediately

### FileService - Listing
- [ ] AC23: listFiles(userId, filters, pagination) with cursor-based pagination
- [ ] AC24: Filters: entityType, entityId, groupId, status
- [ ] AC25: Returns files with nextCursor for pagination

### Quota Tracking
- [ ] AC26: getUserQuota(userId) returns used/limit/remaining bytes + source
- [ ] AC27: Quota updates are atomic (database transaction + SQL increment)
- [ ] AC28: Soft-deleted files DO NOT count toward quota

### Testing
- [ ] AC29: Tests verify three-tier limit resolution (all scenarios)
- [ ] AC30: Tests verify quota enforcement blocks upload when exceeded
- [ ] AC31: Tests verify CASL permissions (owner, group admin, system admin)
- [ ] AC32: Tests verify transaction rollback on storage failure
- [ ] AC33: Tests verify concurrent quota updates don't race

## Technical Notes

### FileLimitsService Implementation

```typescript
// apps/api/src/services/file-limits.service.ts

import { db } from '@raptscallions/db';
import { users, userStorageLimits, groupMembers, groups } from '@raptscallions/db/schema';
import { eq, and, isNull } from 'drizzle-orm';
import { storageConfig } from '@raptscallions/storage';

export interface UserLimits {
  maxFileSizeBytes: number;
  storageQuotaBytes: number;
  usedBytes: number;
  source: 'user_override' | 'role_based' | 'system_default';
}

export class FileLimitsService {
  /**
   * Resolve effective limits for a user.
   * Priority: user override → group role limit → system default
   */
  async getEffectiveLimits(userId: string): Promise<UserLimits> {
    // 1. Check user-specific override
    const userLimit = await db.query.userStorageLimits.findFirst({
      where: eq(userStorageLimits.userId, userId),
    });

    if (userLimit?.maxFileSizeBytes && userLimit?.storageQuotaBytes) {
      return {
        maxFileSizeBytes: userLimit.maxFileSizeBytes,
        storageQuotaBytes: userLimit.storageQuotaBytes,
        usedBytes: userLimit.usedBytes,
        source: 'user_override',
      };
    }

    // 2. Check role-based group limits
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
      with: {
        groupMembers: {
          with: { group: true },
          orderBy: (gm, { desc }) => [desc(gm.createdAt)],
          limit: 1, // Primary group
        },
      },
    });

    if (user?.groupMembers[0]) {
      const group = user.groupMembers[0].group;
      const role = user.groupMembers[0].role;
      const groupLimits = (group.settings as any)?.limits?.[role];

      if (groupLimits) {
        return {
          maxFileSizeBytes: userLimit?.maxFileSizeBytes ?? groupLimits.maxFileSizeBytes,
          storageQuotaBytes: userLimit?.storageQuotaBytes ?? groupLimits.storageQuotaBytes,
          usedBytes: userLimit?.usedBytes ?? 0,
          source: 'role_based',
        };
      }
    }

    // 3. Fallback to system defaults
    return {
      maxFileSizeBytes: storageConfig.DEFAULT_MAX_FILE_SIZE_BYTES,
      storageQuotaBytes: storageConfig.DEFAULT_STORAGE_QUOTA_BYTES,
      usedBytes: userLimit?.usedBytes ?? 0,
      source: 'system_default',
    };
  }

  /**
   * Set user-specific limit override (admin only).
   */
  async setUserOverride(
    userId: string,
    limits: { maxFileSizeBytes?: number; storageQuotaBytes?: number },
    setBy: string,
    reason?: string
  ): Promise<void> {
    await db
      .insert(userStorageLimits)
      .values({
        userId,
        maxFileSizeBytes: limits.maxFileSizeBytes,
        storageQuotaBytes: limits.storageQuotaBytes,
        usedBytes: 0,
        setBy,
        reason,
      })
      .onConflictDoUpdate({
        target: userStorageLimits.userId,
        set: {
          maxFileSizeBytes: limits.maxFileSizeBytes,
          storageQuotaBytes: limits.storageQuotaBytes,
          setBy,
          reason,
          updatedAt: new Date(),
        },
      });
  }
}
```

### FileService Implementation

```typescript
// apps/api/src/services/file.service.ts

import { db } from '@raptscallions/db';
import { files, userStorageLimits } from '@raptscallions/db/schema';
import { eq, and, isNull, sql } from 'drizzle-orm';
import { StorageFactory } from '@raptscallions/storage';
import { storageConfig } from '@raptscallions/storage';
import { NotFoundError, ValidationError, ForbiddenError } from '@raptscallions/core';
import { subject } from '@casl/ability';
import { FileLimitsService } from './file-limits.service.js';
import type { AppAbility } from '@raptscallions/auth';
import type { File } from '@raptscallions/db/schema';

const ALLOWED_MIME_TYPES = [
  'image/jpeg',
  'image/png',
  'image/webp',
  'image/gif',
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'text/plain',
];

export interface UploadFileParams {
  buffer: Buffer;
  filename: string;
  mimeType: string;
  userId: string;
  groupId?: string;
  entityType?: string;
  entityId?: string;
}

export class FileService {
  private storage = StorageFactory.createBackend(storageConfig.STORAGE_BACKEND);
  private limitsService = new FileLimitsService();

  async uploadFile(params: UploadFileParams, ability: AppAbility): Promise<File> {
    // 1. Get effective limits for user
    const limits = await this.limitsService.getEffectiveLimits(params.userId);

    // 2. Validate file size
    if (params.buffer.length > limits.maxFileSizeBytes) {
      throw new ValidationError(
        `File size (${this.formatBytes(params.buffer.length)}) exceeds your limit of ${this.formatBytes(limits.maxFileSizeBytes)}`,
        {
          fileSize: params.buffer.length,
          limit: limits.maxFileSizeBytes,
          source: limits.source,
        }
      );
    }

    // 3. Check storage quota
    if (limits.usedBytes + params.buffer.length > limits.storageQuotaBytes) {
      throw new ValidationError(
        `Storage quota exceeded. Used: ${this.formatBytes(limits.usedBytes)}, Limit: ${this.formatBytes(limits.storageQuotaBytes)}`,
        {
          usedBytes: limits.usedBytes,
          quotaBytes: limits.storageQuotaBytes,
          additionalBytes: params.buffer.length,
          source: limits.source,
        }
      );
    }

    // 4. Validate MIME type
    if (!ALLOWED_MIME_TYPES.includes(params.mimeType)) {
      throw new ValidationError(
        `File type ${params.mimeType} not allowed`,
        { mimeType: params.mimeType, allowed: ALLOWED_MIME_TYPES }
      );
    }

    // 5. Check CASL permissions
    const fileSubject = subject('File', {
      uploadedBy: params.userId,
      groupId: params.groupId,
      entityType: params.entityType,
    });
    if (!ability.can('create', fileSubject as any)) {
      throw new ForbiddenError('You cannot upload files to this location');
    }

    // 6. Upload to storage backend
    const { storageKey, sizeBytes } = await this.storage.upload({
      buffer: params.buffer,
      filename: params.filename,
      mimeType: params.mimeType,
      groupId: params.groupId,
    });

    // 7. Transaction: create file record + update quota
    return await db.transaction(async (tx) => {
      const [file] = await tx
        .insert(files)
        .values({
          name: params.filename,
          mimeType: params.mimeType,
          sizeBytes,
          storageKey,
          storageBackend: this.storage.name,
          uploadedBy: params.userId,
          groupId: params.groupId || null,
          entityType: params.entityType || null,
          entityId: params.entityId || null,
          status: 'active',
        })
        .returning();

      // Update quota atomically
      await tx
        .insert(userStorageLimits)
        .values({
          userId: params.userId,
          usedBytes: sizeBytes,
        })
        .onConflictDoUpdate({
          target: userStorageLimits.userId,
          set: {
            usedBytes: sql`${userStorageLimits.usedBytes} + ${sizeBytes}`,
            updatedAt: new Date(),
          },
        });

      return file;
    });
  }

  async getFile(fileId: string, ability: AppAbility): Promise<File & { signedUrl: string }> {
    const file = await db.query.files.findFirst({
      where: and(eq(files.id, fileId), eq(files.status, 'active')),
    });

    if (!file) {
      throw new NotFoundError('File', fileId);
    }

    // Check CASL permissions
    const fileSubject = subject('File', file);
    if (!ability.can('read', fileSubject as any)) {
      throw new ForbiddenError('You cannot access this file');
    }

    const { url } = await this.storage.getSignedUrl(
      file.storageKey,
      storageConfig.SIGNED_URL_EXPIRES_SECONDS
    );

    return { ...file, signedUrl: url };
  }

  async softDeleteFile(fileId: string, ability: AppAbility): Promise<void> {
    const file = await db.query.files.findFirst({
      where: and(eq(files.id, fileId), eq(files.status, 'active')),
    });

    if (!file) {
      throw new NotFoundError('File', fileId);
    }

    // Check CASL permissions
    const fileSubject = subject('File', file);
    if (!ability.can('delete', fileSubject as any)) {
      throw new ForbiddenError('You cannot delete this file');
    }

    // Transaction: soft delete + update quota
    await db.transaction(async (tx) => {
      await tx
        .update(files)
        .set({
          status: 'soft_deleted',
          deletedAt: new Date(),
        })
        .where(eq(files.id, fileId));

      // Decrement quota
      await tx
        .update(userStorageLimits)
        .set({
          usedBytes: sql`${userStorageLimits.usedBytes} - ${file.sizeBytes}`,
          updatedAt: new Date(),
        })
        .where(eq(userStorageLimits.userId, file.uploadedBy));
    });
  }

  private formatBytes(bytes: number): string {
    if (bytes < 1024) return `${bytes} B`;
    if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
    if (bytes < 1024 * 1024 * 1024) return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(bytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
}
```

## Out of Scope

- API routes (E05-T007, E05-T008)
- Background cleanup jobs (E05-T010)
- Avatar associations (E05-T009)
- Frontend UI (E06)

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
