---
id: "E05-T009"
title: "Avatar and attachment associations"
status: "todo"
priority: "high"
labels: [backend, database, api]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: ["E05-T001", "E05-T007"]
blocks: []
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T009: Avatar and attachment associations

## Description

Add file associations for avatars (users, groups, classes) and attachments (assignments, submissions), establishing foreign keys and cascade behavior. Implement service methods and API routes for setting/getting avatars.

## Acceptance Criteria

### Database Schema Extensions
- [ ] AC1: Add `avatar_file_id` (uuid, nullable, FK to files.id) to users table
- [ ] AC2: Add `avatar_file_id` (uuid, nullable, FK to files.id) to groups table
- [ ] AC3: Add `avatar_file_id` (uuid, nullable, FK to files.id) to classes table
- [ ] AC4: FK cascades: SET NULL on delete (preserve entity if avatar deleted)
- [ ] AC5: Migration 0008_add_avatar_associations.sql
- [ ] AC6: Create assignment_files join table (assignment_id, file_id, file_type)
- [ ] AC7: file_type enum: 'attachment', 'rubric', 'example'
- [ ] AC8: Unique constraint on (assignment_id, file_id)
- [ ] AC9: Indexes on avatar_file_id columns for joins

### Service Layer - Avatar Management
- [ ] AC10: UserService.setAvatar(userId, fileId) validates ownership
- [ ] AC11: GroupService.setAvatar(groupId, fileId) validates permissions
- [ ] AC12: ClassService.setAvatar(classId, fileId) validates permissions
- [ ] AC13: Setting new avatar updates entity and sets file.entityType='avatar'
- [ ] AC14: Setting new avatar removes old avatar association (keeps file record)
- [ ] AC15: getAvatar() returns file with signed download URL
- [ ] AC16: removeAvatar() sets avatar_file_id to NULL

### Service Layer - Assignment Attachments
- [ ] AC17: AssignmentService.addAttachment(assignmentId, fileId, fileType)
- [ ] AC18: AssignmentService.removeAttachment(assignmentId, fileId)
- [ ] AC19: AssignmentService.listAttachments(assignmentId) returns files with URLs
- [ ] AC20: Attachments inherit assignment permissions (via CASL)
- [ ] AC21: Soft-deleting assignment soft-deletes attached files
- [ ] AC22: Max 10 attachments per assignment (configurable)

### API Routes - Avatar Management
- [ ] AC23: PATCH /users/:id/avatar (body: { fileId }) sets user avatar
- [ ] AC24: DELETE /users/:id/avatar removes user avatar
- [ ] AC25: GET /users/:id/avatar returns avatar file metadata + signed URL
- [ ] AC26: Similar routes for /groups/:id/avatar and /classes/:id/avatar
- [ ] AC27: All routes require authentication + ownership/admin permissions
- [ ] AC28: 404 if entity or file not found, 403 if unauthorized

### API Routes - Assignment Attachments
- [ ] AC29: POST /assignments/:id/attachments adds file to assignment
- [ ] AC30: DELETE /assignments/:id/attachments/:fileId removes attachment
- [ ] AC31: GET /assignments/:id/attachments lists all attachments
- [ ] AC32: Routes require teacher/admin permissions on assignment
- [ ] AC33: Validate file exists and user has access before associating

### CASL Integration
- [ ] AC34: Define File abilities: 'read', 'update', 'delete'
- [ ] AC35: Users can read files they uploaded
- [ ] AC36: Users can read files associated with their entities (avatars, assignments)
- [ ] AC37: Group admins can manage group/class avatars
- [ ] AC38: Teachers can manage assignment attachments for their classes
- [ ] AC39: System admins can manage all files

### Testing
- [ ] AC40: Test setting user avatar updates database correctly
- [ ] AC41: Test setting new avatar removes old avatar association
- [ ] AC42: Test avatar permissions (owner can set, others cannot)
- [ ] AC43: Test adding multiple attachments to assignment
- [ ] AC44: Test removing attachment doesn't delete file record
- [ ] AC45: Test cascade behavior when deleting entities
- [ ] AC46: Test CASL permissions for file read/update/delete

## Technical Notes

### Database Migration

```sql
-- packages/db/src/migrations/0008_add_avatar_associations.sql

-- Add avatar_file_id to users
ALTER TABLE users
  ADD COLUMN avatar_file_id uuid REFERENCES files(id) ON DELETE SET NULL;

CREATE INDEX users_avatar_file_id_idx ON users(avatar_file_id);

-- Add avatar_file_id to groups
ALTER TABLE groups
  ADD COLUMN avatar_file_id uuid REFERENCES files(id) ON DELETE SET NULL;

CREATE INDEX groups_avatar_file_id_idx ON groups(avatar_file_id);

-- Add avatar_file_id to classes
ALTER TABLE classes
  ADD COLUMN avatar_file_id uuid REFERENCES files(id) ON DELETE SET NULL;

CREATE INDEX classes_avatar_file_id_idx ON classes(avatar_file_id);

-- Create assignment_files join table
CREATE TYPE file_type AS ENUM ('attachment', 'rubric', 'example');

CREATE TABLE assignment_files (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  assignment_id uuid NOT NULL REFERENCES assignments(id) ON DELETE CASCADE,
  file_id uuid NOT NULL REFERENCES files(id) ON DELETE CASCADE,
  file_type file_type NOT NULL DEFAULT 'attachment',
  created_at timestamptz NOT NULL DEFAULT NOW(),
  UNIQUE (assignment_id, file_id)
);

CREATE INDEX assignment_files_assignment_id_idx ON assignment_files(assignment_id);
CREATE INDEX assignment_files_file_id_idx ON assignment_files(file_id);
```

### Drizzle Schema Updates

```typescript
// packages/db/src/schema/users.ts (addition)

export const users = pgTable('users', {
  // ... existing fields
  avatarFileId: uuid('avatar_file_id').references(() => files.id, { onDelete: 'set null' }),
});

// packages/db/src/schema/groups.ts (addition)

export const groups = pgTable('groups', {
  // ... existing fields
  avatarFileId: uuid('avatar_file_id').references(() => files.id, { onDelete: 'set null' }),
});

// packages/db/src/schema/classes.ts (addition)

export const classes = pgTable('classes', {
  // ... existing fields
  avatarFileId: uuid('avatar_file_id').references(() => files.id, { onDelete: 'set null' }),
});

// packages/db/src/schema/assignment-files.ts (new file)

export const fileTypeEnum = pgEnum('file_type', ['attachment', 'rubric', 'example']);

export const assignmentFiles = pgTable('assignment_files', {
  id: uuid('id').primaryKey().defaultRandom(),
  assignmentId: uuid('assignment_id').notNull().references(() => assignments.id, { onDelete: 'cascade' }),
  fileId: uuid('file_id').notNull().references(() => files.id, { onDelete: 'cascade' }),
  fileType: fileTypeEnum('file_type').notNull().default('attachment'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),
}, (table) => ({
  uniqueAssignmentFile: unique().on(table.assignmentId, table.fileId),
}));

// Relations
export const assignmentFilesRelations = relations(assignmentFiles, ({ one }) => ({
  assignment: one(assignments, {
    fields: [assignmentFiles.assignmentId],
    references: [assignments.id],
  }),
  file: one(files, {
    fields: [assignmentFiles.fileId],
    references: [files.id],
  }),
}));
```

### Service Layer - User Avatar

```typescript
// apps/api/src/services/user.service.ts (additions)

export class UserService {
  // ... existing methods

  async setAvatar(userId: string, fileId: string, ability: AppAbility): Promise<User> {
    // Check user permissions
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      throw new NotFoundError('User', userId);
    }

    ForbiddenError.from(ability).throwUnlessCan('update', subject('User', user));

    // Verify file exists and user has access
    const file = await db.query.files.findFirst({
      where: and(
        eq(files.id, fileId),
        eq(files.status, 'active')
      ),
    });

    if (!file) {
      throw new NotFoundError('File', fileId);
    }

    ForbiddenError.from(ability).throwUnlessCan('read', subject('File', file));

    // Update user avatar
    await db.transaction(async (tx) => {
      // Remove old avatar association (if exists)
      if (user.avatarFileId) {
        await tx.update(files)
          .set({ entityType: null, entityId: null })
          .where(eq(files.id, user.avatarFileId));
      }

      // Set new avatar
      await tx.update(users)
        .set({ avatarFileId: fileId })
        .where(eq(users.id, userId));

      // Update file entity association
      await tx.update(files)
        .set({ entityType: 'avatar', entityId: userId })
        .where(eq(files.id, fileId));
    });

    return await db.query.users.findFirst({
      where: eq(users.id, userId),
      with: { avatarFile: true },
    })!;
  }

  async getAvatar(userId: string, ability: AppAbility): Promise<FileWithSignedUrl | null> {
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
      with: { avatarFile: true },
    });

    if (!user || !user.avatarFile) {
      return null;
    }

    ForbiddenError.from(ability).throwUnlessCan('read', subject('File', user.avatarFile));

    // Generate signed URL
    const backend = StorageBackendFactory.getBackend();
    const { url, expiresAt } = await backend.getSignedUrl(user.avatarFile.storageKey);

    return {
      ...user.avatarFile,
      signedUrl: url,
      signedUrlExpiresAt: expiresAt,
    };
  }

  async removeAvatar(userId: string, ability: AppAbility): Promise<void> {
    const user = await db.query.users.findFirst({
      where: eq(users.id, userId),
    });

    if (!user) {
      throw new NotFoundError('User', userId);
    }

    ForbiddenError.from(ability).throwUnlessCan('update', subject('User', user));

    if (user.avatarFileId) {
      await db.transaction(async (tx) => {
        await tx.update(files)
          .set({ entityType: null, entityId: null })
          .where(eq(files.id, user.avatarFileId!));

        await tx.update(users)
          .set({ avatarFileId: null })
          .where(eq(users.id, userId));
      });
    }
  }
}
```

### Service Layer - Assignment Attachments

```typescript
// apps/api/src/services/assignment.service.ts (additions)

const MAX_ATTACHMENTS_PER_ASSIGNMENT = 10;

export class AssignmentService {
  // ... existing methods

  async addAttachment(
    assignmentId: string,
    fileId: string,
    fileType: 'attachment' | 'rubric' | 'example',
    ability: AppAbility
  ): Promise<void> {
    // Verify assignment exists and user has permission
    const assignment = await db.query.assignments.findFirst({
      where: eq(assignments.id, assignmentId),
      with: { attachments: true },
    });

    if (!assignment) {
      throw new NotFoundError('Assignment', assignmentId);
    }

    ForbiddenError.from(ability).throwUnlessCan('update', subject('Assignment', assignment));

    // Check attachment limit
    if (assignment.attachments.length >= MAX_ATTACHMENTS_PER_ASSIGNMENT) {
      throw new ValidationError(`Maximum ${MAX_ATTACHMENTS_PER_ASSIGNMENT} attachments per assignment`);
    }

    // Verify file exists and user has access
    const file = await db.query.files.findFirst({
      where: and(
        eq(files.id, fileId),
        eq(files.status, 'active')
      ),
    });

    if (!file) {
      throw new NotFoundError('File', fileId);
    }

    ForbiddenError.from(ability).throwUnlessCan('read', subject('File', file));

    // Add attachment
    await db.transaction(async (tx) => {
      await tx.insert(assignmentFiles).values({
        assignmentId,
        fileId,
        fileType,
      });

      // Update file entity association
      await tx.update(files)
        .set({ entityType: 'assignment_attachment', entityId: assignmentId })
        .where(eq(files.id, fileId));
    });
  }

  async removeAttachment(assignmentId: string, fileId: string, ability: AppAbility): Promise<void> {
    const assignment = await db.query.assignments.findFirst({
      where: eq(assignments.id, assignmentId),
    });

    if (!assignment) {
      throw new NotFoundError('Assignment', assignmentId);
    }

    ForbiddenError.from(ability).throwUnlessCan('update', subject('Assignment', assignment));

    await db.transaction(async (tx) => {
      await tx.delete(assignmentFiles)
        .where(and(
          eq(assignmentFiles.assignmentId, assignmentId),
          eq(assignmentFiles.fileId, fileId)
        ));

      // Clear file entity association
      await tx.update(files)
        .set({ entityType: null, entityId: null })
        .where(eq(files.id, fileId));
    });
  }

  async listAttachments(assignmentId: string, ability: AppAbility): Promise<FileWithSignedUrl[]> {
    const assignment = await db.query.assignments.findFirst({
      where: eq(assignments.id, assignmentId),
      with: {
        attachments: {
          with: { file: true },
        },
      },
    });

    if (!assignment) {
      throw new NotFoundError('Assignment', assignmentId);
    }

    ForbiddenError.from(ability).throwUnlessCan('read', subject('Assignment', assignment));

    const backend = StorageBackendFactory.getBackend();

    // Generate signed URLs for all attachments
    const filesWithUrls = await Promise.all(
      assignment.attachments.map(async (attachment) => {
        const { url, expiresAt } = await backend.getSignedUrl(attachment.file.storageKey);

        return {
          ...attachment.file,
          signedUrl: url,
          signedUrlExpiresAt: expiresAt,
          fileType: attachment.fileType,
        };
      })
    );

    return filesWithUrls;
  }
}
```

### API Routes - Avatars

```typescript
// apps/api/src/routes/users.routes.ts (additions)

/**
 * PATCH /users/:id/avatar
 * Set user avatar
 */
typedApp.patch<{
  Params: { id: string };
  Body: { fileId: string };
}>(
  '/:id/avatar',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
      body: z.object({ fileId: z.string().uuid() }),
    },
  },
  async (request, reply) => {
    const user = await userService.setAvatar(
      request.params.id,
      request.body.fileId,
      request.ability
    );

    return reply.send({ data: user });
  }
);

/**
 * GET /users/:id/avatar
 * Get user avatar with signed URL
 */
typedApp.get<{ Params: { id: string } }>(
  '/:id/avatar',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
    },
  },
  async (request, reply) => {
    const avatar = await userService.getAvatar(request.params.id, request.ability);

    if (!avatar) {
      return reply.status(404).send({ error: 'Avatar not found' });
    }

    return reply.send({ data: avatar });
  }
);

/**
 * DELETE /users/:id/avatar
 * Remove user avatar
 */
typedApp.delete<{ Params: { id: string } }>(
  '/:id/avatar',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
    },
  },
  async (request, reply) => {
    await userService.removeAvatar(request.params.id, request.ability);
    return reply.status(204).send();
  }
);
```

### API Routes - Assignment Attachments

```typescript
// apps/api/src/routes/assignments.routes.ts (additions)

/**
 * POST /assignments/:id/attachments
 * Add file attachment to assignment
 */
typedApp.post<{
  Params: { id: string };
  Body: { fileId: string; fileType: 'attachment' | 'rubric' | 'example' };
}>(
  '/:id/attachments',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
      body: z.object({
        fileId: z.string().uuid(),
        fileType: z.enum(['attachment', 'rubric', 'example']).default('attachment'),
      }),
    },
  },
  async (request, reply) => {
    await assignmentService.addAttachment(
      request.params.id,
      request.body.fileId,
      request.body.fileType,
      request.ability
    );

    return reply.status(201).send();
  }
);

/**
 * GET /assignments/:id/attachments
 * List assignment attachments with signed URLs
 */
typedApp.get<{ Params: { id: string } }>(
  '/:id/attachments',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
    },
  },
  async (request, reply) => {
    const attachments = await assignmentService.listAttachments(
      request.params.id,
      request.ability
    );

    return reply.send({ data: attachments });
  }
);

/**
 * DELETE /assignments/:id/attachments/:fileId
 * Remove attachment from assignment
 */
typedApp.delete<{ Params: { id: string; fileId: string } }>(
  '/:id/attachments/:fileId',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({
        id: z.string().uuid(),
        fileId: z.string().uuid(),
      }),
    },
  },
  async (request, reply) => {
    await assignmentService.removeAttachment(
      request.params.id,
      request.params.fileId,
      request.ability
    );

    return reply.status(204).send();
  }
);
```

### CASL Permissions

```typescript
// packages/auth/src/abilities/file.abilities.ts

import { AbilityBuilder } from '@casl/ability';
import type { AppAbility } from './types.js';
import type { User, File } from '@raptscallions/db';

export function defineFileAbilities(user: User, builder: AbilityBuilder<AppAbility>) {
  const { can, cannot } = builder;

  // System admins can do everything with files
  if (user.role === 'system_admin') {
    can('manage', 'File');
    return;
  }

  // Users can read files they uploaded
  can('read', 'File', { uploadedBy: user.id });

  // Users can update/delete their own files
  can('update', 'File', { uploadedBy: user.id });
  can('delete', 'File', { uploadedBy: user.id });

  // Users can read files associated with their entities (avatars, assignments)
  // This is handled via entity-level permissions (e.g., can read User â†’ can read User's avatar)

  // Group admins can manage files in their groups
  if (user.role === 'group_admin') {
    // Implementation depends on group membership queries
    // can('manage', 'File', { groupId: { $in: userGroupIds } });
  }

  // Teachers can manage assignment attachments for their classes
  if (user.role === 'teacher') {
    // Implementation depends on class membership queries
    // can('manage', 'File', { entityType: 'assignment_attachment', entityId: { $in: assignmentIds } });
  }

  // Students can read assignment attachments
  if (user.role === 'student') {
    // can('read', 'File', { entityType: 'assignment_attachment' });
  }
}
```

## Out of Scope

- Submission file attachments (handled in submissions epic)
- Bulk avatar updates
- Avatar image processing (cropping, resizing)
- File preview/thumbnail generation
- Attachment ordering/sorting
- File versioning for attachments
- Attachment comments/annotations

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
