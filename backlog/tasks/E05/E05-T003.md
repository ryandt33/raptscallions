---
id: "E05-T003"
title: "S3/MinIO storage implementation"
status: "todo"
priority: "critical"
labels: [backend, infrastructure, s3]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: ["E05-T002"]
blocks: ["E05-T006", "E05-T007"]
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T003: S3/MinIO storage implementation

## Description

Implement S3StorageBackend class using AWS SDK v3 with MinIO compatibility. Add MinIO service to docker-compose.yml for local development. This is the default storage backend for production deployments.

## Acceptance Criteria

### S3 Backend Implementation
- [ ] AC1: S3StorageBackend class implements IStorageBackend interface
- [ ] AC2: Uses @aws-sdk/client-s3 v3 for all operations
- [ ] AC3: Uses @aws-sdk/s3-request-presigner for signed URLs
- [ ] AC4: MinIO compatibility with forcePathStyle option support
- [ ] AC5: Storage key format: `{groupId}/{year}/{month}/{uuid}-{filename}`
- [ ] AC6: Upload method streams buffer to S3 with PutObjectCommand
- [ ] AC7: Download method retrieves object with GetObjectCommand
- [ ] AC8: Delete method removes object with DeleteObjectCommand
- [ ] AC9: Exists method checks with HeadObjectCommand
- [ ] AC10: getSignedUrl generates 15-minute pre-signed URL

### Docker Compose Integration
- [ ] AC11: Add MinIO service to docker-compose.yml (image: minio/minio:latest)
- [ ] AC12: MinIO ports: 9000 (API), 9001 (console)
- [ ] AC13: MinIO environment: MINIO_ROOT_USER, MINIO_ROOT_PASSWORD
- [ ] AC14: MinIO volume mount for data persistence
- [ ] AC15: MinIO bucket auto-creation via init container
- [ ] AC16: API service depends on MinIO health check

### Configuration
- [ ] AC17: Environment variables: S3_ENDPOINT, S3_BUCKET, S3_ACCESS_KEY_ID, S3_SECRET_ACCESS_KEY
- [ ] AC18: S3_FORCE_PATH_STYLE defaults to true for MinIO
- [ ] AC19: S3_REGION defaults to 'us-east-1'
- [ ] AC20: Configuration documented in .env.example

### Error Handling
- [ ] AC21: Network failures throw StorageError with retry context
- [ ] AC22: Invalid credentials throw StorageError with auth context
- [ ] AC23: Bucket not found throws StorageError with bucket name
- [ ] AC24: Object not found in download/delete returns gracefully

### Testing
- [ ] AC25: Integration tests with MinIO test container
- [ ] AC26: Tests verify upload → download → delete flow
- [ ] AC27: Tests verify signed URL generation and expiration
- [ ] AC28: Tests verify MinIO forcePathStyle compatibility
- [ ] AC29: Tests verify storage key format

## Technical Notes

```typescript
// packages/storage/src/backends/s3.backend.ts

import {
  S3Client,
  PutObjectCommand,
  GetObjectCommand,
  DeleteObjectCommand,
  HeadObjectCommand,
} from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import { v4 as uuidv4 } from 'uuid';
import { storageConfig } from '../config.js';
import { StorageError } from '../errors.js';
import type { IStorageBackend, UploadParams, UploadResult, SignedUrl } from '../types.js';

export class S3StorageBackend implements IStorageBackend {
  readonly name = 's3';
  private client: S3Client;
  private bucket: string;

  constructor() {
    this.bucket = storageConfig.S3_BUCKET!;

    this.client = new S3Client({
      region: storageConfig.S3_REGION,
      endpoint: storageConfig.S3_ENDPOINT,
      credentials: {
        accessKeyId: storageConfig.S3_ACCESS_KEY_ID!,
        secretAccessKey: storageConfig.S3_SECRET_ACCESS_KEY!,
      },
      forcePathStyle: storageConfig.S3_FORCE_PATH_STYLE,
    });
  }

  async upload(params: UploadParams): Promise<UploadResult> {
    const storageKey = this.generateStorageKey(params);

    try {
      await this.client.send(
        new PutObjectCommand({
          Bucket: this.bucket,
          Key: storageKey,
          Body: params.buffer,
          ContentType: params.mimeType,
          Metadata: {
            originalFilename: params.filename,
            groupId: params.groupId || '',
          },
        })
      );

      return {
        storageKey,
        sizeBytes: params.buffer.length,
      };
    } catch (error) {
      throw new StorageError('Failed to upload file to S3', { error, storageKey });
    }
  }

  async download(storageKey: string): Promise<Buffer> {
    try {
      const response = await this.client.send(
        new GetObjectCommand({
          Bucket: this.bucket,
          Key: storageKey,
        })
      );

      // Convert stream to buffer
      const chunks: Uint8Array[] = [];
      for await (const chunk of response.Body as any) {
        chunks.push(chunk);
      }
      return Buffer.concat(chunks);
    } catch (error) {
      throw new StorageError('Failed to download file from S3', { error, storageKey });
    }
  }

  async delete(storageKey: string): Promise<void> {
    try {
      await this.client.send(
        new DeleteObjectCommand({
          Bucket: this.bucket,
          Key: storageKey,
        })
      );
    } catch (error) {
      // Don't throw if object doesn't exist
      if ((error as any).name !== 'NoSuchKey') {
        throw new StorageError('Failed to delete file from S3', { error, storageKey });
      }
    }
  }

  async exists(storageKey: string): Promise<boolean> {
    try {
      await this.client.send(
        new HeadObjectCommand({
          Bucket: this.bucket,
          Key: storageKey,
        })
      );
      return true;
    } catch {
      return false;
    }
  }

  async getSignedUrl(storageKey: string, expiresIn: number = 900): Promise<SignedUrl> {
    try {
      const command = new GetObjectCommand({
        Bucket: this.bucket,
        Key: storageKey,
      });

      const url = await getSignedUrl(this.client, command, { expiresIn });
      const expiresAt = new Date(Date.now() + expiresIn * 1000);

      return { url, expiresAt };
    } catch (error) {
      throw new StorageError('Failed to generate signed URL', { error, storageKey });
    }
  }

  private generateStorageKey(params: UploadParams): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const uuid = uuidv4();
    const ext = params.filename.split('.').pop() || '';

    const groupPath = params.groupId || 'system';
    return `${groupPath}/${year}/${month}/${uuid}.${ext}`;
  }
}
```

### Docker Compose Configuration

```yaml
# docker-compose.yml

services:
  # ... existing services ...

  # MinIO Object Storage (S3-compatible)
  minio:
    image: minio/minio:latest
    container_name: raptscallions-minio
    restart: unless-stopped
    ports:
      - "9000:9000"  # API
      - "9001:9001"  # Console UI
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    volumes:
      - minio_data:/data
    command: server /data --console-address ":9001"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
      interval: 30s
      timeout: 20s
      retries: 3

  # MinIO bucket initialization
  minio-setup:
    image: minio/mc:latest
    container_name: raptscallions-minio-setup
    depends_on:
      minio:
        condition: service_healthy
    entrypoint: >
      /bin/sh -c "
      mc alias set myminio http://minio:9000 minioadmin minioadmin;
      mc mb myminio/raptscallions-files --ignore-existing;
      mc anonymous set download myminio/raptscallions-files;
      exit 0;
      "
    restart: "no"

  # Update API service
  api:
    # ... existing config ...
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      minio:
        condition: service_healthy
    environment:
      # ... existing env vars ...
      STORAGE_BACKEND: s3
      S3_ENDPOINT: http://minio:9000
      S3_REGION: us-east-1
      S3_BUCKET: raptscallions-files
      S3_ACCESS_KEY_ID: minioadmin
      S3_SECRET_ACCESS_KEY: minioadmin
      S3_FORCE_PATH_STYLE: true

volumes:
  # ... existing volumes ...
  minio_data:
    driver: local
```

## Out of Scope

- Azure, GCS, Aliyun implementations (E05-T005)
- Local filesystem implementation (E05-T004)
- File service integration (E05-T006)
- API routes (E05-T007, E05-T008)

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
