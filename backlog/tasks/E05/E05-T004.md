---
id: "E05-T004"
title: "Local filesystem storage implementation"
status: "todo"
priority: "high"
task_type: "backend"
workflow: "development"
labels: [backend, storage]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
agentic_style: "outcome-focused"
depends_on: ["E05-T002a", "E05-T002b"]
blocks: []
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-18T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T004: Local filesystem storage implementation

## Description

Implement local filesystem storage backend as a fallback for development and self-hosted deployments without cloud storage. Files are stored in an organized directory structure with token-based download URLs that bypass the API for direct file serving.

## Why This Matters

Self-hosted schools and small districts may not want or afford cloud storage costs. Local filesystem storage provides a zero-cost, zero-configuration option that works immediately after deployment. It's also essential for local development without cloud credentials.

## Acceptance Criteria

### Core Storage Operations
- [ ] AC1: Backend implements IStorageBackend interface from E05-T002a
- [ ] AC2: Files upload to configurable local directory with organized path structure
- [ ] AC3: Files download correctly with proper error handling for missing files
- [ ] AC4: Files delete from disk (soft delete tracking handled by database layer)
- [ ] AC5: Existence checks correctly identify present/missing files
- [ ] AC6: File writes are atomic (no partial files on failure/crash)

### Token-Based Download URLs
- [ ] AC7: Signed URLs use JWT tokens instead of S3-style presigning
- [ ] AC8: Tokens include storage key and expiration, signed with app secret
- [ ] AC9: Download endpoint validates token and serves file with correct headers
- [ ] AC10: Expired or invalid tokens are rejected with clear error

### Error Handling
- [ ] AC11: Directory creation failures produce clear StorageError
- [ ] AC12: Disk write failures (permissions, full disk) produce clear StorageError
- [ ] AC13: Missing files on download throw NotFoundError
- [ ] AC14: All errors include context for debugging (path, operation, underlying error)

### Docker Integration
- [ ] AC15: Volume mount configured for file persistence across restarts
- [ ] AC16: Storage directory excluded from Docker image build
- [ ] AC17: Setup documented in README for self-hosted deployments

## Technical Notes

### Implementation

```typescript
// packages/storage/src/backends/local.backend.ts

import { createWriteStream } from 'fs';
import { access, mkdir, readFile, unlink, writeFile, rename } from 'fs/promises';
import { join, dirname } from 'path';
import { pipeline } from 'stream/promises';
import { v4 as uuidv4 } from 'uuid';
import jwt from 'jsonwebtoken';
import type {
  IStorageBackend,
  UploadParams,
  UploadResult,
  SignedUrl,
} from '../types.js';
import { StorageError, NotFoundError } from '../errors.js';
import { storageConfig } from '../config.js';
import { logger } from '@raptscallions/telemetry';

interface DownloadToken {
  storageKey: string;
  exp: number;
}

export class LocalStorageBackend implements IStorageBackend {
  readonly name = 'local';
  private basePath: string;
  private secret: string;

  constructor() {
    this.basePath = storageConfig.LOCAL_STORAGE_PATH;
    this.secret = storageConfig.SESSION_SECRET;
  }

  /**
   * Upload file to local filesystem
   */
  async upload(params: UploadParams): Promise<UploadResult> {
    const storageKey = this.generateStorageKey(params);
    const filePath = this.getFilePath(storageKey);
    const tempPath = `${filePath}.tmp`;

    try {
      // Ensure directory exists
      await mkdir(dirname(filePath), { recursive: true });

      // Write to temporary file first (atomic write)
      await writeFile(tempPath, params.buffer);

      // Rename to final location
      await rename(tempPath, filePath);

      logger.info({ storageKey, sizeBytes: params.buffer.length }, 'File uploaded to local storage');

      return {
        storageKey,
        sizeBytes: params.buffer.length,
      };
    } catch (error) {
      logger.error({ error, storageKey, filePath }, 'Failed to upload file to local storage');

      // Clean up temp file if it exists
      try {
        await unlink(tempPath);
      } catch {
        // Ignore cleanup errors
      }

      throw new StorageError(`Failed to upload file: ${(error as Error).message}`, { storageKey });
    }
  }

  /**
   * Download file from local filesystem
   */
  async download(storageKey: string): Promise<Buffer> {
    const filePath = this.getFilePath(storageKey);

    try {
      // Check if file exists
      await access(filePath);

      // Read file
      const buffer = await readFile(filePath);

      logger.debug({ storageKey, sizeBytes: buffer.length }, 'File downloaded from local storage');

      return buffer;
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        throw new NotFoundError('File', storageKey);
      }

      logger.error({ error, storageKey, filePath }, 'Failed to download file from local storage');
      throw new StorageError(`Failed to download file: ${error.message}`, { storageKey });
    }
  }

  /**
   * Delete file from local filesystem
   */
  async delete(storageKey: string): Promise<void> {
    const filePath = this.getFilePath(storageKey);

    try {
      await unlink(filePath);
      logger.info({ storageKey }, 'File deleted from local storage');
    } catch (error: any) {
      if (error.code === 'ENOENT') {
        // File doesn't exist, consider it deleted
        return;
      }

      logger.error({ error, storageKey, filePath }, 'Failed to delete file from local storage');
      throw new StorageError(`Failed to delete file: ${error.message}`, { storageKey });
    }
  }

  /**
   * Check if file exists
   */
  async exists(storageKey: string): Promise<boolean> {
    const filePath = this.getFilePath(storageKey);

    try {
      await access(filePath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Generate token-based download URL (not S3-style pre-signed)
   */
  async getSignedUrl(storageKey: string, expiresIn: number = 900): Promise<SignedUrl> {
    const expiresAt = new Date(Date.now() + expiresIn * 1000);

    // Generate JWT token containing storageKey and expiration
    const token = jwt.sign(
      { storageKey } as DownloadToken,
      this.secret,
      { expiresIn }
    );

    // URL points to API route that validates token
    const url = `${storageConfig.API_BASE_URL}/files/download/${token}`;

    return { url, expiresAt };
  }

  /**
   * Validate download token (called by API route)
   */
  validateToken(token: string): string {
    try {
      const decoded = jwt.verify(token, this.secret) as DownloadToken;
      return decoded.storageKey;
    } catch (error) {
      throw new StorageError('Invalid or expired download token');
    }
  }

  /**
   * Generate storage key with directory structure
   */
  private generateStorageKey(params: UploadParams): string {
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const uuid = uuidv4();
    const ext = params.filename.split('.').pop() || '';
    const groupPath = params.groupId || 'system';

    return `${groupPath}/${year}/${month}/${uuid}.${ext}`;
  }

  /**
   * Convert storage key to absolute file path
   */
  private getFilePath(storageKey: string): string {
    return join(this.basePath, storageKey);
  }
}
```

### API Route for Token-Based Downloads

```typescript
// apps/api/src/routes/files.routes.ts (addition)

/**
 * GET /files/download/:token
 * Download file using token (for local storage backend)
 */
typedApp.get<{ Params: { token: string } }>(
  '/download/:token',
  {
    schema: {
      params: z.object({ token: z.string() }),
    },
  },
  async (request, reply) => {
    // This only works with local backend
    if (storageConfig.STORAGE_BACKEND !== 'local') {
      return reply.status(404).send({ error: 'Route not available for current storage backend' });
    }

    const backend = StorageBackendFactory.getBackend() as LocalStorageBackend;

    try {
      // Validate token and extract storage key
      const storageKey = backend.validateToken(request.params.token);

      // Get file from database to check permissions and get metadata
      const file = await db.query.files.findFirst({
        where: eq(files.storageKey, storageKey),
      });

      if (!file || file.status !== 'active') {
        return reply.status(404).send({ error: 'File not found' });
      }

      // Download file
      const buffer = await backend.download(storageKey);

      // Set response headers
      reply.header('Content-Type', file.mimeType);
      reply.header('Content-Disposition', `attachment; filename="${file.name}"`);
      reply.header('Content-Length', buffer.length);

      return reply.send(buffer);
    } catch (error) {
      if (error instanceof StorageError) {
        return reply.status(403).send({ error: error.message });
      }
      throw error;
    }
  }
);
```

### Configuration

```typescript
// packages/storage/src/config.ts (additions)

export const storageConfigSchema = z.object({
  // ... existing fields

  // Local Storage
  LOCAL_STORAGE_PATH: z.string().default('./storage/uploads'),
  API_BASE_URL: z.string().url().default('http://localhost:3000/api'),
});
```

### Docker Compose Integration

```yaml
# docker-compose.yml

services:
  api:
    build: ./apps/api
    volumes:
      - file_storage:/app/storage/uploads  # Persistent storage
    environment:
      STORAGE_BACKEND: local
      LOCAL_STORAGE_PATH: /app/storage/uploads

volumes:
  file_storage:
    driver: local
```

### .dockerignore

```
# .dockerignore
node_modules
dist
.env
storage/uploads/*  # Don't copy local uploads into image
```

### Integration Test Examples

```typescript
// packages/storage/src/backends/__tests__/local.backend.test.ts

import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { LocalStorageBackend } from '../local.backend.js';
import { mkdir, rm } from 'fs/promises';
import { join } from 'path';

describe('LocalStorageBackend', () => {
  let backend: LocalStorageBackend;
  let testDir: string;

  beforeEach(async () => {
    testDir = join(__dirname, 'test-storage');
    await mkdir(testDir, { recursive: true });

    // Override basePath for testing
    backend = new LocalStorageBackend();
    (backend as any).basePath = testDir;
  });

  afterEach(async () => {
    await rm(testDir, { recursive: true, force: true });
  });

  describe('upload', () => {
    it('should upload file and create directory structure', async () => {
      const buffer = Buffer.from('test content');
      const result = await backend.upload({
        buffer,
        filename: 'test.txt',
        mimeType: 'text/plain',
        groupId: 'group-123',
        userId: 'user-456',
      });

      expect(result.storageKey).toMatch(/^group-123\/\d{4}\/\d{2}\/[a-f0-9-]+\.txt$/);
      expect(result.sizeBytes).toBe(buffer.length);

      // Verify file exists
      const exists = await backend.exists(result.storageKey);
      expect(exists).toBe(true);
    });

    it('should use atomic write (tmp + rename)', async () => {
      const buffer = Buffer.from('test content');

      // Mock writeFile to fail on final write, should clean up tmp
      // (Implementation detail test)
    });
  });

  describe('download', () => {
    it('should download uploaded file', async () => {
      const originalBuffer = Buffer.from('test content');
      const { storageKey } = await backend.upload({
        buffer: originalBuffer,
        filename: 'test.txt',
        mimeType: 'text/plain',
        userId: 'user-123',
      });

      const downloadedBuffer = await backend.download(storageKey);

      expect(downloadedBuffer.toString()).toBe(originalBuffer.toString());
    });

    it('should throw NotFoundError if file does not exist', async () => {
      await expect(
        backend.download('nonexistent/file.txt')
      ).rejects.toThrow(NotFoundError);
    });
  });

  describe('delete', () => {
    it('should delete file from disk', async () => {
      const { storageKey } = await backend.upload({
        buffer: Buffer.from('test'),
        filename: 'test.txt',
        mimeType: 'text/plain',
        userId: 'user-123',
      });

      await backend.delete(storageKey);

      const exists = await backend.exists(storageKey);
      expect(exists).toBe(false);
    });

    it('should not throw if file does not exist', async () => {
      await expect(
        backend.delete('nonexistent/file.txt')
      ).resolves.not.toThrow();
    });
  });

  describe('getSignedUrl', () => {
    it('should generate token-based URL with expiration', async () => {
      const storageKey = 'group-123/2026/01/file.txt';
      const { url, expiresAt } = await backend.getSignedUrl(storageKey, 900);

      expect(url).toContain('/files/download/');
      expect(expiresAt.getTime()).toBeGreaterThan(Date.now());
      expect(expiresAt.getTime()).toBeLessThanOrEqual(Date.now() + 900 * 1000);
    });

    it('should generate valid JWT token', async () => {
      const storageKey = 'group-123/2026/01/file.txt';
      const { url } = await backend.getSignedUrl(storageKey);

      const token = url.split('/download/')[1];
      const validatedKey = backend.validateToken(token);

      expect(validatedKey).toBe(storageKey);
    });

    it('should reject expired tokens', async () => {
      const storageKey = 'group-123/2026/01/file.txt';
      const { url } = await backend.getSignedUrl(storageKey, -1); // Already expired

      const token = url.split('/download/')[1];

      expect(() => backend.validateToken(token)).toThrow(StorageError);
    });
  });

  describe('exists', () => {
    it('should return true for existing file', async () => {
      const { storageKey } = await backend.upload({
        buffer: Buffer.from('test'),
        filename: 'test.txt',
        mimeType: 'text/plain',
        userId: 'user-123',
      });

      const exists = await backend.exists(storageKey);
      expect(exists).toBe(true);
    });

    it('should return false for non-existing file', async () => {
      const exists = await backend.exists('nonexistent/file.txt');
      expect(exists).toBe(false);
    });
  });
});
```

## Out of Scope

- Image processing (thumbnails, resizing)
- File streaming for very large files (>100MB)
- Compression/decompression
- Filesystem quota management (relies on OS)
- Network file systems (NFS, SMB)
- File versioning
- Checksum verification

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
