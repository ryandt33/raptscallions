---
id: E04-T011
title: Message attachments schema (uploaded files)
status: todo
priority: medium
labels:
  - backend
  - database
  - enhancement
assignee: ""
workflow_state: DRAFT
epic: E04
depends_on:
  - E04-T001
  - E04-T009
  - E05 - complete whole epic
blocks: []
breakpoint: false
assigned_agent: ""
created_at: 2026-01-14T00:00:00Z
updated_at: 2026-01-14T00:00:00Z
spec_file: backlog/docs/specs/E04/E04-T011-spec.md
test_files: []
code_files: []
pr_url: ""
---

# E04-T011: Message Attachments Schema (Uploaded Files)

## Description

Create a dedicated schema for message attachments, allowing users to upload files (documents, images, etc.) that are associated with chat messages. This provides a proper relational structure for file references with queryability and data integrity.

**Use Cases:**

- Student uploads essay for AI feedback
- Teacher shares reference materials in chat
- User uploads image for AI analysis
- Documents attached as context for conversation

**Note:** This task covers only the database schema and types. Actual file upload/storage implementation (S3, local storage) is deferred to a separate task.

## Acceptance Criteria

### Schema Changes

- [ ] AC1: Create `message_attachments` table with proper foreign keys
- [ ] AC2: Fields: id, message_id, filename, mime_type, size, storage_provider, storage_key
- [ ] AC3: Add soft delete support via `deleted_at` timestamp
- [ ] AC4: Add timestamps: `uploaded_at`, `deleted_at`
- [ ] AC5: Foreign key to messages with CASCADE delete
- [ ] AC6: Migration file 0012_create_message_attachments.sql

### Indexes and Constraints

- [ ] AC7: Index on `message_id` for efficient attachment retrieval
- [ ] AC8: Index on `mime_type` for filtering by file type
- [ ] AC9: Index on `deleted_at` for soft delete queries

### Type Safety

- [ ] AC10: Export `MessageAttachment` and `NewMessageAttachment` types
- [ ] AC11: Create Zod schema for attachment validation in `@raptscallions/core/schemas`
- [ ] AC12: Validate filename, mime_type, size constraints

### Relations

- [ ] AC13: Define Drizzle relation between messages and attachments
- [ ] AC14: Support querying messages with attachments in single query

### Interim Meta Field Support (E04-T009)

- [ ] AC15: Extend `messageMetaSchema` in E04-T009 with optional `attachments` field
- [ ] AC16: Document migration path from meta.attachments to dedicated table

### Testing

- [ ] AC17: Tests verify attachment creation with valid message reference
- [ ] AC18: Tests verify CASCADE delete (attachment removed when message deleted)
- [ ] AC19: Tests verify soft delete behavior
- [ ] AC20: Tests verify Zod schema validation for attachment metadata

## Technical Notes

### Phase 1: Extend Message Meta (E04-T009)

Add attachment support to the existing meta field as an interim solution:

```typescript
// packages/core/src/schemas/message-meta.schema.ts
export const documentRefSchema = z.object({
  id: z.string().uuid(),
  filename: z.string().min(1).max(255),
  mimeType: z.string().min(1).max(100),
  size: z.number().int().positive().max(100_000_000), // 100MB max
  storageKey: z.string().min(1), // S3 key, file path, etc.
  storageProvider: z.enum(["s3", "local", "gcs"]).optional().default("local"),
  uploadedAt: z.string().datetime(),
});

export const messageMetaSchema = z
  .object({
    // ... existing fields (tokens, model, latency_ms, etc.) ...

    // Document attachments (interim solution)
    attachments: z.array(documentRefSchema).optional(),
  })
  .passthrough();
```

**Usage in Meta Field:**

```typescript
const message: NewMessage = {
  sessionId: "session-123",
  role: "user",
  content: "Please review my essay",
  seq: 5,
  meta: {
    attachments: [
      {
        id: "att-uuid-1",
        filename: "essay.pdf",
        mimeType: "application/pdf",
        size: 524288,
        storageKey: "uploads/user-789/att-uuid-1.pdf",
        storageProvider: "s3",
        uploadedAt: new Date().toISOString(),
      },
    ],
  },
};
```

### Phase 2: Dedicated Table (This Task)

Create proper relational table for better queryability:

```typescript
// packages/db/src/schema/message-attachments.ts
export const storageProviderEnum = pgEnum("storage_provider", [
  "s3",
  "local",
  "gcs",
]);

export const messageAttachments = pgTable(
  "message_attachments",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    messageId: uuid("message_id")
      .notNull()
      .references(() => messages.id, { onDelete: "cascade" }),

    // File metadata
    filename: varchar("filename", { length: 255 }).notNull(),
    mimeType: varchar("mime_type", { length: 100 }).notNull(),
    size: integer("size").notNull(), // bytes

    // Storage reference
    storageProvider: storageProviderEnum("storage_provider")
      .notNull()
      .default("local"),
    storageKey: varchar("storage_key", { length: 500 }).notNull(),

    // Optional metadata
    meta: jsonb("meta").notNull().default("{}"),

    // Timestamps
    uploadedAt: timestamp("uploaded_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    deletedAt: timestamp("deleted_at", { withTimezone: true }),
  },
  (table) => ({
    messageIdIdx: index("message_attachments_message_id_idx").on(
      table.messageId
    ),
    mimeTypeIdx: index("message_attachments_mime_type_idx").on(table.mimeType),
    deletedAtIdx: index("message_attachments_deleted_at_idx").on(
      table.deletedAt
    ),
  })
);

export type MessageAttachment = typeof messageAttachments.$inferSelect;
export type NewMessageAttachment = typeof messageAttachments.$inferInsert;
```

### Drizzle Relations

```typescript
// In messages.ts
export const messagesRelations = relations(messages, ({ many }) => ({
  attachments: many(messageAttachments),
}));

// In message-attachments.ts
export const messageAttachmentsRelations = relations(
  messageAttachments,
  ({ one }) => ({
    message: one(messages, {
      fields: [messageAttachments.messageId],
      references: [messages.id],
    }),
  })
);
```

### Query Patterns

```typescript
// Query messages with attachments
const messagesWithAttachments = await db.query.messages.findMany({
  where: eq(messages.sessionId, sessionId),
  with: {
    attachments: {
      where: isNull(messageAttachments.deletedAt),
    },
  },
  orderBy: asc(messages.seq),
});

// Find all messages with PDF attachments
const pdfMessages = await db
  .select()
  .from(messages)
  .innerJoin(messageAttachments, eq(messages.id, messageAttachments.messageId))
  .where(
    and(
      eq(messageAttachments.mimeType, "application/pdf"),
      isNull(messageAttachments.deletedAt)
    )
  );

// Soft delete attachment
await db
  .update(messageAttachments)
  .set({ deletedAt: new Date() })
  .where(eq(messageAttachments.id, attachmentId));
```

### Migration Strategy

**Data Migration from Meta Field:**
When migrating from meta.attachments to dedicated table:

```sql
-- Migration step: Extract attachments from meta field
INSERT INTO message_attachments (
  id,
  message_id,
  filename,
  mime_type,
  size,
  storage_provider,
  storage_key,
  uploaded_at
)
SELECT
  (attachment->>'id')::uuid,
  m.id,
  attachment->>'filename',
  attachment->>'mimeType',
  (attachment->>'size')::integer,
  COALESCE(attachment->>'storageProvider', 'local')::storage_provider,
  attachment->>'storageKey',
  (attachment->>'uploadedAt')::timestamp with time zone
FROM messages m,
  jsonb_array_elements(m.meta->'attachments') AS attachment
WHERE m.meta->'attachments' IS NOT NULL;

-- Optional: Clear meta.attachments after migration
UPDATE messages
SET meta = meta - 'attachments'
WHERE meta->'attachments' IS NOT NULL;
```

### Security Considerations

**Validation:**

- Filename: sanitize, prevent path traversal
- MIME type: validate against allowlist
- Size: enforce max file size limits
- Storage key: validate format per provider

**Access Control:**

- Only message author or permitted users can access attachments
- Implement pre-signed URLs for S3 (future task)
- Soft delete preserves audit trail

**Supported MIME Types (Example Allowlist):**

```typescript
const ALLOWED_MIME_TYPES = [
  // Documents
  "application/pdf",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",

  // Images
  "image/jpeg",
  "image/png",
  "image/gif",
  "image/webp",

  // Text
  "text/plain",
  "text/markdown",

  // Archives (if needed)
  "application/zip",
];
```

### Out of Scope

This task focuses on schema only. Deferred to future tasks:

- Actual file upload API endpoint
- S3/storage service integration
- File validation (virus scanning, etc.)
- Download/streaming endpoints
- Pre-signed URL generation
- Thumbnail generation for images
- File size quota enforcement per user/group

## History

| Date       | State | Agent   | Notes                                                           |
| ---------- | ----- | ------- | --------------------------------------------------------------- |
| 2026-01-14 | DRAFT | analyst | Task created based on user request for document storage support |

## Reviews

### UX Review

- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### Plan Review

- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### Code Review

- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### QA Review

- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**
