---
id: "E04-T012"
title: "AI credentials schema and encryption"
status: "todo"
priority: "critical"
labels: [backend, database, security, ai]
assignee: ""
workflow_state: "DRAFT"
epic: "E04"
depends_on: []
blocks: ["E04-T013", "E04-T014"]
breakpoint: false
assigned_agent: ""
created_at: "2026-01-16T00:00:00Z"
updated_at: "2026-01-16T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E04-T012: AI Credentials Schema and Encryption

## Description

Create the database schema and encryption infrastructure for storing per-group AI provider credentials. This enables each group (district/school) to bring their own API keys, with proper encryption at rest.

**Key Decisions:**
- Separate `ai_credentials` table (supports multiple providers per group in future)
- Application-level encryption with `@noble/ciphers` (pure JS, portable, audited by Cure53)
- XChaCha20-Poly1305 authenticated encryption (same security as libsodium, no native deps)
- OpenRouter as only provider for MVP (schema supports others)
- Group admins manage their own credentials

## Acceptance Criteria

### Schema
- [ ] AC1: Create `ai_credentials` table in `packages/db/src/schema/`
- [ ] AC2: Fields: id, group_id, provider, encrypted_key, nonce, is_active, created_at, updated_at, last_used_at, created_by
- [ ] AC3: Foreign key to groups with CASCADE delete
- [ ] AC4: Unique constraint on (group_id, provider, is_active) where is_active = true
- [ ] AC5: Index on group_id for fast lookups
- [ ] AC6: Migration file `0012_create_ai_credentials.sql`
- [ ] AC7: Export TypeScript types (AiCredential, NewAiCredential)

### Encryption Service
- [ ] AC8: Create encryption service in `packages/core/src/encryption/`
- [ ] AC9: Use `@noble/ciphers` for XChaCha20-Poly1305 authenticated encryption
- [ ] AC10: `encrypt(plaintext: string): { ciphertext: Uint8Array, nonce: Uint8Array }`
- [ ] AC11: `decrypt(ciphertext: Uint8Array, nonce: Uint8Array): string`
- [ ] AC12: Encryption key loaded from `CREDENTIAL_ENCRYPTION_KEY` env var
- [ ] AC13: Validation that key is exactly 32 bytes (256 bits)
- [ ] AC14: Clear error if encryption key is missing or invalid

### Environment Configuration
- [ ] AC15: Add `CREDENTIAL_ENCRYPTION_KEY` to `.env.example` with generation instructions
- [ ] AC16: Add to config validation in startup

### Testing
- [ ] AC17: Schema tests verify constraints (unique active credential per provider)
- [ ] AC18: Encryption service tests verify round-trip encrypt/decrypt
- [ ] AC19: Tests verify different keys produce different ciphertext
- [ ] AC20: Tests verify tampering detection (authenticated encryption)

## Technical Notes

### Schema Design

```typescript
// packages/db/src/schema/ai-credentials.ts
import {
  pgTable,
  uuid,
  varchar,
  boolean,
  timestamp,
  index,
  unique,
  customType,
} from "drizzle-orm/pg-core";
import { groups } from "./groups.js";
import { users } from "./users.js";

// Custom type for binary data (encrypted key and nonce)
const bytea = customType<{ data: Buffer }>({
  dataType() {
    return "bytea";
  },
});

export const aiCredentials = pgTable(
  "ai_credentials",
  {
    id: uuid("id").primaryKey().defaultRandom(),
    groupId: uuid("group_id")
      .notNull()
      .references(() => groups.id, { onDelete: "cascade" }),

    // Provider identifier (extensible for future)
    provider: varchar("provider", { length: 50 }).notNull(), // 'openrouter', 'anthropic', 'openai'

    // Encrypted API key (libsodium secretbox)
    encryptedKey: bytea("encrypted_key").notNull(),
    nonce: bytea("nonce").notNull(), // 24 bytes for XSalsa20

    // Only one active credential per provider per group
    isActive: boolean("is_active").notNull().default(true),

    // Audit fields
    createdAt: timestamp("created_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
      .defaultNow()
      .notNull(),
    lastUsedAt: timestamp("last_used_at", { withTimezone: true }),
    createdBy: uuid("created_by")
      .notNull()
      .references(() => users.id, { onDelete: "set null" }),
  },
  (table) => ({
    groupIdIdx: index("ai_credentials_group_id_idx").on(table.groupId),
    // Only one active credential per group+provider
    uniqueActiveCredential: unique("ai_credentials_unique_active").on(
      table.groupId,
      table.provider
    ).where(sql`is_active = true`),
  })
);

export type AiCredential = typeof aiCredentials.$inferSelect;
export type NewAiCredential = typeof aiCredentials.$inferInsert;
```

### Encryption Service

```typescript
// packages/core/src/encryption/credential-encryption.ts
import { xchacha20poly1305 } from "@noble/ciphers/chacha";
import { randomBytes } from "@noble/ciphers/webcrypto";
import { hexToBytes } from "@noble/ciphers/utils";

const NONCE_BYTES = 24; // XChaCha20 uses 24-byte nonce
const KEY_BYTES = 32;   // 256-bit key

let encryptionKey: Uint8Array | null = null;

/**
 * Initialize encryption with key from environment
 * Call once at startup
 */
export function initializeEncryption(): void {
  const keyHex = process.env.CREDENTIAL_ENCRYPTION_KEY;

  if (!keyHex) {
    throw new Error(
      "CREDENTIAL_ENCRYPTION_KEY environment variable is required. " +
      "Generate with: openssl rand -hex 32"
    );
  }

  const key = hexToBytes(keyHex);

  if (key.length !== KEY_BYTES) {
    throw new Error(
      `CREDENTIAL_ENCRYPTION_KEY must be exactly ${KEY_BYTES} bytes (${KEY_BYTES * 2} hex chars). ` +
      `Got ${key.length} bytes.`
    );
  }

  encryptionKey = key;
}

/**
 * Encrypt a plaintext string (e.g., API key)
 */
export function encrypt(plaintext: string): { ciphertext: Uint8Array; nonce: Uint8Array } {
  if (!encryptionKey) {
    throw new Error("Encryption not initialized. Call initializeEncryption() first.");
  }

  const nonce = randomBytes(NONCE_BYTES);
  const cipher = xchacha20poly1305(encryptionKey, nonce);
  const ciphertext = cipher.encrypt(new TextEncoder().encode(plaintext));

  return { ciphertext, nonce };
}

/**
 * Decrypt a ciphertext back to plaintext
 */
export function decrypt(ciphertext: Uint8Array, nonce: Uint8Array): string {
  if (!encryptionKey) {
    throw new Error("Encryption not initialized. Call initializeEncryption() first.");
  }

  try {
    const cipher = xchacha20poly1305(encryptionKey, nonce);
    const plaintext = cipher.decrypt(ciphertext);
    return new TextDecoder().decode(plaintext);
  } catch {
    throw new Error("Decryption failed: invalid ciphertext or key");
  }
}

/**
 * Check if encryption is initialized
 */
export function isEncryptionInitialized(): boolean {
  return encryptionKey !== null;
}
```

### Migration

```sql
-- packages/db/src/migrations/0012_create_ai_credentials.sql

-- Up Migration
CREATE TABLE ai_credentials (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  group_id UUID NOT NULL REFERENCES groups(id) ON DELETE CASCADE,
  provider VARCHAR(50) NOT NULL,
  encrypted_key BYTEA NOT NULL,
  nonce BYTEA NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  last_used_at TIMESTAMPTZ,
  created_by UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL
);

-- Index for fast group lookups
CREATE INDEX ai_credentials_group_id_idx ON ai_credentials(group_id);

-- Only one active credential per group+provider
CREATE UNIQUE INDEX ai_credentials_unique_active
  ON ai_credentials(group_id, provider)
  WHERE is_active = true;

-- Comment for documentation
COMMENT ON TABLE ai_credentials IS 'Encrypted API keys for AI providers, per group';
COMMENT ON COLUMN ai_credentials.encrypted_key IS 'XChaCha20-Poly1305 encrypted API key';
COMMENT ON COLUMN ai_credentials.nonce IS '24-byte nonce for decryption';

-- Down Migration
DROP TABLE IF EXISTS ai_credentials;
```

### Environment Variable

```bash
# .env.example
# AI Credential Encryption (REQUIRED)
# Generate with: openssl rand -hex 32
# CRITICAL: Back this up securely. Lost key = lost credentials.
CREDENTIAL_ENCRYPTION_KEY=
```

### Package Dependency

```bash
# Add to packages/core
pnpm add @noble/ciphers
```

**Why @noble/ciphers over sodium-native:**
- Pure JavaScript - no native compilation, works everywhere
- Audited by Cure53 (same firm that audited 1Password)
- Same cryptographic guarantees (XChaCha20-Poly1305)
- ~50KB vs ~500KB native binary per platform
- No "docker build failed" issues on Alpine/ARM/Windows

## Security Considerations

1. **Key Storage**: Encryption key in `.env` only, never in database
2. **Key Rotation**: To rotate, decrypt all → change key → re-encrypt all (migration task)
3. **Authenticated Encryption**: XChaCha20-Poly1305 prevents tampering (AEAD)
4. **Unique Nonces**: Random 24-byte nonce per encryption ensures identical keys produce different ciphertext
5. **Extended Nonce**: XChaCha20 uses 24-byte nonces (vs 12-byte), safe to generate randomly without collision risk

## Out of Scope

- Key rotation automation (future task)
- Hardware security module (HSM) integration
- Multiple encryption keys (for key rotation period)
- Credential service (E04-T013)
- API routes (E04-T013)

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-16 | DRAFT | pm | Task created for per-group AI credentials |

## Reviews

### Plan Review
- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### Code Review
- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### QA Review
- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**
