---
id: "E04-T013"
title: "Credential management service and API"
status: "todo"
priority: "critical"
labels: [backend, api, security, ai]
assignee: ""
workflow_state: "DRAFT"
epic: "E04"
depends_on: ["E04-T012"]
blocks: ["E04-T014", "E04-T015"]
breakpoint: false
assigned_agent: ""
created_at: "2026-01-16T00:00:00Z"
updated_at: "2026-01-16T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E04-T013: Credential Management Service and API

## Description

Implement the service layer and API routes for managing AI credentials. This enables group admins to:
- Add their OpenRouter API key
- View credential status (without exposing the key)
- Rotate/replace credentials
- Deactivate credentials

**Security Focus:**
- API keys are never returned in responses (only masked hints)
- CASL permissions enforce group_admin access
- Audit logging for all credential operations

## Acceptance Criteria

### Credential Service
- [ ] AC1: `CredentialService` class in `apps/api/src/services/`
- [ ] AC2: `create(input)` - encrypts and stores new credential
- [ ] AC3: `getActiveForGroup(groupId)` - returns decrypted credential or throws `AiNotConfiguredError`
- [ ] AC4: `listForGroup(groupId)` - returns credentials WITHOUT decrypted keys (masked)
- [ ] AC5: `deactivate(credentialId)` - soft deactivate (set is_active = false)
- [ ] AC6: `delete(credentialId)` - hard delete credential
- [ ] AC7: `updateLastUsed(credentialId)` - touch last_used_at timestamp
- [ ] AC8: `validateKey(apiKey, provider)` - test key works before saving (optional)

### API Routes
- [ ] AC9: `POST /groups/:groupId/credentials` - create credential
- [ ] AC10: `GET /groups/:groupId/credentials` - list credentials (masked)
- [ ] AC11: `DELETE /groups/:groupId/credentials/:id` - delete credential
- [ ] AC12: `PATCH /groups/:groupId/credentials/:id/deactivate` - deactivate

### Authorization (CASL)
- [ ] AC13: `system_admin` can manage any group's credentials
- [ ] AC14: `group_admin` can only manage their own group's credentials
- [ ] AC15: Teachers and students cannot access credential endpoints

### Validation
- [ ] AC16: Zod schema for credential creation input
- [ ] AC17: Validate provider is supported ('openrouter' for MVP)
- [ ] AC18: Validate API key format (basic sanity check)

### Error Handling
- [ ] AC19: `AiNotConfiguredError` when group has no active credential
- [ ] AC20: `CredentialNotFoundError` for invalid credential ID
- [ ] AC21: `DuplicateCredentialError` if active credential exists for provider

### Testing
- [ ] AC22: Service tests with mocked encryption
- [ ] AC23: API route tests verify authorization
- [ ] AC24: Tests verify key is never exposed in responses

## Technical Notes

### Service Implementation

```typescript
// apps/api/src/services/credential.service.ts
import { db } from "@raptscallions/db";
import { aiCredentials } from "@raptscallions/db/schema";
import { encrypt, decrypt } from "@raptscallions/core/encryption";
import { eq, and } from "drizzle-orm";

export class CredentialService {
  /**
   * Create a new credential for a group
   */
  async create(input: {
    groupId: string;
    provider: string;
    apiKey: string;
    createdBy: string;
  }): Promise<{ id: string; provider: string; createdAt: Date }> {
    // Check for existing active credential
    const existing = await db.query.aiCredentials.findFirst({
      where: and(
        eq(aiCredentials.groupId, input.groupId),
        eq(aiCredentials.provider, input.provider),
        eq(aiCredentials.isActive, true)
      ),
    });

    if (existing) {
      throw new DuplicateCredentialError(input.groupId, input.provider);
    }

    // Encrypt the API key
    const { ciphertext, nonce } = encrypt(input.apiKey);

    // Store
    const [credential] = await db
      .insert(aiCredentials)
      .values({
        groupId: input.groupId,
        provider: input.provider,
        encryptedKey: ciphertext,
        nonce: nonce,
        createdBy: input.createdBy,
      })
      .returning({ id: aiCredentials.id, provider: aiCredentials.provider, createdAt: aiCredentials.createdAt });

    return credential;
  }

  /**
   * Get active credential for a group (decrypted)
   * Used internally by chat service
   */
  async getActiveForGroup(
    groupId: string,
    provider: string = "openrouter"
  ): Promise<{ id: string; apiKey: string; provider: string }> {
    const credential = await db.query.aiCredentials.findFirst({
      where: and(
        eq(aiCredentials.groupId, groupId),
        eq(aiCredentials.provider, provider),
        eq(aiCredentials.isActive, true)
      ),
    });

    if (!credential) {
      throw new AiNotConfiguredError(groupId);
    }

    // Decrypt
    const apiKey = decrypt(credential.encryptedKey, credential.nonce);

    return {
      id: credential.id,
      apiKey,
      provider: credential.provider,
    };
  }

  /**
   * List credentials for a group (masked, for UI display)
   */
  async listForGroup(groupId: string): Promise<CredentialListItem[]> {
    const credentials = await db.query.aiCredentials.findMany({
      where: eq(aiCredentials.groupId, groupId),
      orderBy: (creds, { desc }) => [desc(creds.createdAt)],
    });

    return credentials.map((c) => ({
      id: c.id,
      provider: c.provider,
      isActive: c.isActive,
      createdAt: c.createdAt,
      lastUsedAt: c.lastUsedAt,
      // Masked hint: "sk-or-...x4f2"
      keyHint: this.maskKey(decrypt(c.encryptedKey, c.nonce)),
    }));
  }

  /**
   * Mask API key for display: "sk-or-v1-abc...xyz"
   */
  private maskKey(key: string): string {
    if (key.length <= 12) return "***";
    return `${key.slice(0, 8)}...${key.slice(-4)}`;
  }

  /**
   * Deactivate a credential (soft delete)
   */
  async deactivate(credentialId: string): Promise<void> {
    await db
      .update(aiCredentials)
      .set({ isActive: false, updatedAt: new Date() })
      .where(eq(aiCredentials.id, credentialId));
  }

  /**
   * Hard delete a credential
   */
  async delete(credentialId: string): Promise<void> {
    await db
      .delete(aiCredentials)
      .where(eq(aiCredentials.id, credentialId));
  }

  /**
   * Update last used timestamp
   */
  async updateLastUsed(credentialId: string): Promise<void> {
    await db
      .update(aiCredentials)
      .set({ lastUsedAt: new Date() })
      .where(eq(aiCredentials.id, credentialId));
  }
}

// Singleton instance
export const credentialService = new CredentialService();
```

### Custom Errors

```typescript
// packages/core/src/errors/ai-errors.ts

export class AiNotConfiguredError extends Error {
  readonly code = "AI_NOT_CONFIGURED";
  readonly statusCode = 424; // Failed Dependency

  constructor(groupId: string) {
    super(`AI is not configured for this group. Please add an API key in settings.`);
    this.name = "AiNotConfiguredError";
  }
}

export class DuplicateCredentialError extends Error {
  readonly code = "DUPLICATE_CREDENTIAL";
  readonly statusCode = 409; // Conflict

  constructor(groupId: string, provider: string) {
    super(`An active ${provider} credential already exists for this group.`);
    this.name = "DuplicateCredentialError";
  }
}

export class CredentialNotFoundError extends Error {
  readonly code = "CREDENTIAL_NOT_FOUND";
  readonly statusCode = 404;

  constructor(credentialId: string) {
    super(`Credential not found: ${credentialId}`);
    this.name = "CredentialNotFoundError";
  }
}
```

### API Routes

```typescript
// apps/api/src/routes/credentials.routes.ts
import { FastifyPluginAsync } from "fastify";
import { z } from "zod";
import { credentialService } from "../services/credential.service.js";

const createCredentialSchema = z.object({
  provider: z.enum(["openrouter"]), // Extensible later
  apiKey: z.string().min(10).max(500),
});

export const credentialRoutes: FastifyPluginAsync = async (app) => {
  // Create credential
  app.post<{
    Params: { groupId: string };
    Body: z.infer<typeof createCredentialSchema>;
  }>(
    "/groups/:groupId/credentials",
    {
      preHandler: [app.authenticate, app.requirePermission("create", "AiCredential")],
      schema: { body: createCredentialSchema },
    },
    async (request, reply) => {
      const credential = await credentialService.create({
        groupId: request.params.groupId,
        provider: request.body.provider,
        apiKey: request.body.apiKey,
        createdBy: request.user.id,
      });

      return reply.status(201).send({ data: credential });
    }
  );

  // List credentials (masked)
  app.get<{ Params: { groupId: string } }>(
    "/groups/:groupId/credentials",
    {
      preHandler: [app.authenticate, app.requirePermission("read", "AiCredential")],
    },
    async (request, reply) => {
      const credentials = await credentialService.listForGroup(request.params.groupId);
      return reply.send({ data: credentials });
    }
  );

  // Delete credential
  app.delete<{ Params: { groupId: string; id: string } }>(
    "/groups/:groupId/credentials/:id",
    {
      preHandler: [app.authenticate, app.requirePermission("delete", "AiCredential")],
    },
    async (request, reply) => {
      await credentialService.delete(request.params.id);
      return reply.status(204).send();
    }
  );

  // Deactivate credential
  app.patch<{ Params: { groupId: string; id: string } }>(
    "/groups/:groupId/credentials/:id/deactivate",
    {
      preHandler: [app.authenticate, app.requirePermission("update", "AiCredential")],
    },
    async (request, reply) => {
      await credentialService.deactivate(request.params.id);
      return reply.status(204).send();
    }
  );
};
```

### CASL Permissions

```typescript
// packages/auth/src/permissions/credential.permissions.ts
import { AbilityBuilder } from "@casl/ability";

export function defineCredentialPermissions(
  { can, cannot }: AbilityBuilder<AppAbility>,
  user: User
) {
  switch (user.role) {
    case "system_admin":
      // System admins can manage all credentials
      can("manage", "AiCredential");
      break;

    case "group_admin":
      // Group admins can manage only their group's credentials
      can("manage", "AiCredential", { groupId: user.groupId });
      break;

    case "teacher":
    case "student":
      // No credential access
      cannot("manage", "AiCredential");
      break;
  }
}
```

### Response Format

```typescript
// List response (masked)
{
  "data": [
    {
      "id": "cred-uuid-1",
      "provider": "openrouter",
      "isActive": true,
      "createdAt": "2026-01-16T10:00:00Z",
      "lastUsedAt": "2026-01-16T14:30:00Z",
      "keyHint": "sk-or-v1...x4f2"  // Never full key!
    }
  ]
}
```

## Security Notes

1. **Never return full API key** - only masked hints in list responses
2. **Audit logging** - consider logging credential create/delete events (future)
3. **Rate limiting** - apply standard rate limits to prevent enumeration
4. **Permission checks** - always verify user has access to the group

## Out of Scope

- Credential rotation automation
- API key validation before saving (call provider to check)
- Multiple credentials per provider (for A/B testing)
- Frontend UI (separate epic)

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-16 | DRAFT | pm | Task created for credential management service and API |

## Reviews

### Plan Review
- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### Code Review
- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**

### QA Review
- **Reviewer:**
- **Date:**
- **Verdict:**
- **Notes:**
