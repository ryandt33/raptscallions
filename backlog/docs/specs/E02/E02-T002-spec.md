# E02-T002: Sessions Table and Lucia Setup - Implementation Specification

**Task ID:** E02-T002
**Epic:** E02 - Authentication
**Status:** ANALYZED
**Created:** 2026-01-12
**Analyst:** analyst

---

## Overview

This task implements the sessions table for Lucia v3 authentication, configures Lucia with the Drizzle PostgreSQL adapter, and creates session middleware for Fastify to attach user context to requests. This is a foundational piece of the authentication system that enables secure, session-based authentication with automatic session rotation.

---

## Architecture Context

### System Position

```
┌─────────────────────────────────────────────────────────────┐
│                    HTTP Request Flow                         │
└─────────────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────┐
│  Fastify Server (apps/api)                                   │
│  ┌──────────────────────────────────────────────────────────┤
│  │ Session Middleware (NEW)                                  │
│  │ - Validate session cookie                                 │
│  │ - Extend fresh sessions                                   │
│  │ - Clear expired sessions                                  │
│  │ - Attach user/session to request                          │
│  └──────────────┬───────────────────────────────────────────┤
│                 ↓                                             │
│  ┌──────────────────────────────────────────────────────────┤
│  │ Route Handlers                                            │
│  │ - Access user via request.user                            │
│  │ - Access session via request.session                      │
│  └──────────────────────────────────────────────────────────┤
└─────────────────────────────────────────────────────────────┘
                             ↓
┌─────────────────────────────────────────────────────────────┐
│  Lucia Auth Instance (packages/auth) [NEW PACKAGE]           │
│  ┌──────────────────────────────────────────────────────────┤
│  │ - validateSession()                                       │
│  │ - createSession()                                         │
│  │ - invalidateSession()                                     │
│  │ - invalidateUserSessions()                                │
│  └──────────────┬───────────────────────────────────────────┤
└─────────────────┼───────────────────────────────────────────┘
                  ↓
┌─────────────────────────────────────────────────────────────┐
│  Database (packages/db)                                      │
│  ┌──────────────────────────────────────────────────────────┤
│  │ users table (existing)                                    │
│  │ - id, email, name, password_hash, status                  │
│  └──────────────────────────────────────────────────────────┤
│  ┌──────────────────────────────────────────────────────────┤
│  │ sessions table (NEW)                                      │
│  │ - id (varchar 255), user_id (uuid FK), expires_at         │
│  └──────────────────────────────────────────────────────────┤
└─────────────────────────────────────────────────────────────┘
```

### Dependencies

- **Depends on:** E02-T001 (Users table - COMPLETED)
- **Blocks:**
  - E02-T003 (Password authentication)
  - E02-T004 (OAuth providers setup)
  - E02-T005 (Login/logout routes)

---

## Database Schema

### New Table: sessions

```typescript
// packages/db/src/schema/sessions.ts

import { pgTable, varchar, uuid, timestamp } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { users } from "./users.js";

/**
 * Sessions table for Lucia v3 authentication.
 *
 * Lucia manages session lifecycle:
 * - Session IDs are cryptographically random 40-character strings
 * - Sessions have configurable expiration (default 30 days)
 * - Fresh sessions (< 50% lifetime remaining) are automatically extended
 * - Expired sessions are validated as null and should be deleted
 *
 * @see https://lucia-auth.com/database/
 */
export const sessions = pgTable("sessions", {
  /**
   * Session ID - generated by Lucia, 40-character random string.
   * This is the value stored in the session cookie.
   */
  id: varchar("id", { length: 255 }).primaryKey(),

  /**
   * User ID foreign key with CASCADE delete.
   * When a user is deleted, all their sessions are automatically removed.
   */
  userId: uuid("user_id")
    .notNull()
    .references(() => users.id, { onDelete: "cascade" }),

  /**
   * Session expiration timestamp.
   * Lucia checks this during validation - expired sessions return null.
   */
  expiresAt: timestamp("expires_at", { withTimezone: true }).notNull(),
});

/**
 * Relations for Drizzle query builder.
 * Enables: db.query.sessions.findFirst({ with: { user: true } })
 */
export const sessionsRelations = relations(sessions, ({ one }) => ({
  user: one(users, {
    fields: [sessions.userId],
    references: [users.id],
  }),
}));

/**
 * Session type for select operations (reading from database).
 */
export type Session = typeof sessions.$inferSelect;

/**
 * NewSession type for insert operations (writing to database).
 */
export type NewSession = typeof sessions.$inferInsert;
```

### Migration: 0004_create_sessions.sql

```sql
-- Migration: Create sessions table for Lucia v3
-- Up migration

CREATE TABLE IF NOT EXISTS sessions (
    id VARCHAR(255) PRIMARY KEY,
    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
    expires_at TIMESTAMPTZ NOT NULL
);

-- Index for faster user session lookups (e.g., invalidate all user sessions)
CREATE INDEX sessions_user_id_idx ON sessions(user_id);

-- Index for session cleanup (finding expired sessions)
CREATE INDEX sessions_expires_at_idx ON sessions(expires_at);
```

### Migration: 0004_create_sessions.down.sql

```sql
-- Migration: Drop sessions table
-- Down migration

DROP INDEX IF EXISTS sessions_expires_at_idx;
DROP INDEX IF EXISTS sessions_user_id_idx;
DROP TABLE IF EXISTS sessions;
```

---

## New Package: @raptscallions/auth

### Package Structure

```
packages/auth/
├── src/
│   ├── lucia.ts              # Lucia instance and configuration
│   ├── types.ts              # Type augmentations and interfaces
│   ├── session.service.ts    # Session CRUD operations
│   └── index.ts              # Barrel exports
├── __tests__/
│   ├── lucia.test.ts         # Lucia configuration tests
│   └── session.service.test.ts  # Session operations tests
├── package.json
├── tsconfig.json
└── vitest.config.ts
```

### package.json

```json
{
  "name": "@raptscallions/auth",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js"
    }
  },
  "scripts": {
    "build": "tsc",
    "dev": "tsc --watch",
    "clean": "rm -rf dist *.tsbuildinfo",
    "test": "vitest run",
    "test:watch": "vitest"
  },
  "dependencies": {
    "@raptscallions/core": "workspace:*",
    "@raptscallions/db": "workspace:*",
    "lucia": "^3.2.0",
    "@lucia-auth/adapter-drizzle": "^1.1.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.10.0",
    "typescript": "^5.3.0",
    "vitest": "^1.1.0"
  }
}
```

### lucia.ts

```typescript
// packages/auth/src/lucia.ts

import { Lucia } from "lucia";
import { DrizzlePostgreSQLAdapter } from "@lucia-auth/adapter-drizzle";
import { db } from "@raptscallions/db";
import { sessions, users } from "@raptscallions/db/schema";

/**
 * Database user attributes returned by Lucia.
 * Maps to columns in the users table that should be included in session user object.
 */
interface DatabaseUserAttributes {
  email: string;
  name: string;
  status: "active" | "suspended" | "pending_verification";
}

/**
 * Lucia adapter connecting to PostgreSQL via Drizzle.
 * This adapter handles all session CRUD operations against the database.
 */
const adapter = new DrizzlePostgreSQLAdapter(db, sessions, users);

/**
 * Lucia authentication instance.
 *
 * Configuration:
 * - 30-day session expiration (can be adjusted)
 * - Secure cookies in production (https only)
 * - httpOnly cookies (not accessible via JavaScript)
 * - sameSite: lax (CSRF protection)
 * - path: "/" (available to entire app)
 *
 * Session lifecycle:
 * - Fresh sessions (< 50% lifetime remaining) are automatically extended
 * - Expired sessions return null from validateSession()
 * - Lucia handles all session ID generation and expiration logic
 *
 * @example
 * // Validate session
 * const { session, user } = await lucia.validateSession(sessionId);
 *
 * // Create session
 * const session = await lucia.createSession(userId, {});
 *
 * // Invalidate session
 * await lucia.invalidateSession(sessionId);
 */
export const lucia = new Lucia(adapter, {
  sessionCookie: {
    name: "auth_session", // Cookie name
    expires: false, // Session cookies (cleared when browser closes)
    attributes: {
      secure: process.env.NODE_ENV === "production", // HTTPS only in production
      httpOnly: true, // Not accessible via JavaScript
      sameSite: "lax", // CSRF protection
      path: "/", // Available to entire application
    },
  },

  // Session expiration: 30 days
  sessionExpiresIn: {
    activePeriod: 1000 * 60 * 60 * 24 * 30, // 30 days
    idlePeriod: 1000 * 60 * 60 * 24 * 30, // 30 days
  },

  /**
   * Map database user attributes to session user object.
   * This determines what user fields are available on request.user
   */
  getUserAttributes: (attributes: DatabaseUserAttributes) => {
    return {
      email: attributes.email,
      name: attributes.name,
      status: attributes.status,
    };
  },
});

/**
 * Type augmentation for Lucia.
 * This makes TypeScript aware of our custom user attributes.
 */
declare module "lucia" {
  interface Register {
    Lucia: typeof lucia;
    DatabaseUserAttributes: DatabaseUserAttributes;
  }
}
```

### types.ts

```typescript
// packages/auth/src/types.ts

import type { User as LuciaUser, Session as LuciaSession } from "lucia";

/**
 * Authenticated user type with all user attributes from getUserAttributes.
 * This is what's available on request.user after authentication.
 */
export type SessionUser = LuciaUser;

/**
 * Active session with user relationship.
 * This is what's available on request.session after authentication.
 */
export type Session = LuciaSession;

/**
 * Result from session validation.
 * Either both session and user are present, or both are null (expired/invalid).
 */
export interface SessionValidationResult {
  session: Session | null;
  user: SessionUser | null;
}

/**
 * Session cookie attributes for setting/clearing cookies.
 */
export interface SessionCookieAttributes {
  name: string;
  value: string;
  attributes: {
    secure: boolean;
    httpOnly: boolean;
    sameSite: "lax" | "strict" | "none";
    path: string;
    maxAge?: number;
    expires?: Date;
  };
}
```

### session.service.ts

```typescript
// packages/auth/src/session.service.ts

import { lucia } from "./lucia.js";
import type { Session, SessionUser, SessionValidationResult } from "./types.js";
import { UnauthorizedError } from "@raptscallions/core/errors";

/**
 * Session management service.
 * Wraps Lucia methods with application-specific logic and error handling.
 */
export class SessionService {
  /**
   * Validates a session ID and returns the session and user.
   *
   * If the session is "fresh" (< 50% of lifetime remaining), Lucia will
   * automatically extend it by updating the expires_at timestamp.
   *
   * @param sessionId - Session ID from cookie
   * @returns Session and user if valid, or both null if expired/invalid
   *
   * @example
   * const { session, user } = await sessionService.validate(sessionId);
   * if (!session) {
   *   throw new UnauthorizedError("Session expired");
   * }
   */
  async validate(sessionId: string): Promise<SessionValidationResult> {
    try {
      const result = await lucia.validateSession(sessionId);
      return result;
    } catch (error) {
      // Lucia throws if session ID is malformed or database error occurs
      throw new UnauthorizedError("Invalid session");
    }
  }

  /**
   * Creates a new session for a user.
   *
   * @param userId - User ID to create session for
   * @returns Created session object
   *
   * @example
   * const session = await sessionService.create(user.id);
   * reply.setCookie("auth_session", session.id, lucia.sessionCookieAttributes);
   */
  async create(userId: string): Promise<Session> {
    try {
      // Lucia generates a cryptographically random session ID
      // and calculates expires_at based on sessionExpiresIn config
      const session = await lucia.createSession(userId, {});
      return session;
    } catch (error) {
      throw new Error("Failed to create session");
    }
  }

  /**
   * Invalidates a single session (logout).
   *
   * @param sessionId - Session ID to invalidate
   *
   * @example
   * await sessionService.invalidate(request.session.id);
   * reply.setCookie("auth_session", "", { maxAge: 0 });
   */
  async invalidate(sessionId: string): Promise<void> {
    try {
      await lucia.invalidateSession(sessionId);
    } catch (error) {
      // Ignore errors if session doesn't exist (already logged out)
      // This is safe because the end result is the same
    }
  }

  /**
   * Invalidates all sessions for a user (logout from all devices).
   *
   * @param userId - User ID whose sessions to invalidate
   *
   * @example
   * await sessionService.invalidateUserSessions(user.id);
   */
  async invalidateUserSessions(userId: string): Promise<void> {
    try {
      await lucia.invalidateUserSessions(userId);
    } catch (error) {
      throw new Error("Failed to invalidate user sessions");
    }
  }

  /**
   * Creates a blank session cookie for clearing the session.
   * Use this after logout to remove the cookie from the client.
   *
   * @returns Cookie attributes for clearing the session cookie
   *
   * @example
   * const cookie = sessionService.createBlankSessionCookie();
   * reply.setCookie(cookie.name, cookie.value, cookie.attributes);
   */
  createBlankSessionCookie() {
    return lucia.createBlankSessionCookie();
  }

  /**
   * Gets the session cookie name.
   *
   * @returns Cookie name (default: "auth_session")
   */
  get sessionCookieName(): string {
    return lucia.sessionCookieName;
  }

  /**
   * Gets the session cookie attributes for setting cookies.
   *
   * @returns Cookie attributes (secure, httpOnly, sameSite, path)
   */
  get sessionCookieAttributes() {
    return lucia.sessionCookie.attributes;
  }
}

/**
 * Singleton session service instance.
 * Export this for use across the application.
 */
export const sessionService = new SessionService();
```

### index.ts

```typescript
// packages/auth/src/index.ts

// Export Lucia instance
export { lucia } from "./lucia.js";

// Export session service
export { SessionService, sessionService } from "./session.service.js";

// Export types
export type {
  SessionUser,
  Session,
  SessionValidationResult,
  SessionCookieAttributes,
} from "./types.js";
```

---

## Fastify Integration

### Update packages/db/src/schema/index.ts

```typescript
// Add sessions export
export * from "./sessions.js";
```

### Type Augmentation for Fastify

```typescript
// apps/api/src/types/fastify.d.ts [NEW FILE]

import type { SessionUser, Session } from "@raptscallions/auth";

/**
 * Augment Fastify request with session and user.
 * These properties are set by the session middleware.
 */
declare module "fastify" {
  interface FastifyRequest {
    user: SessionUser | null;
    session: Session | null;
  }
}
```

### Session Middleware

```typescript
// apps/api/src/middleware/session.middleware.ts [NEW FILE]

import { FastifyPluginAsync } from "fastify";
import { sessionService } from "@raptscallions/auth";

/**
 * Session middleware for Fastify.
 *
 * Runs on every request (onRequest hook):
 * 1. Reads session cookie
 * 2. Validates session with Lucia
 * 3. Extends fresh sessions automatically
 * 4. Clears expired sessions
 * 5. Attaches user and session to request
 *
 * After this middleware runs:
 * - request.user will be SessionUser | null
 * - request.session will be Session | null
 *
 * Routes can check authentication with:
 * ```typescript
 * if (!request.user) {
 *   throw new UnauthorizedError("Not authenticated");
 * }
 * ```
 */
export const sessionMiddleware: FastifyPluginAsync = async (app) => {
  app.addHook("onRequest", async (request, reply) => {
    // Get session ID from cookie
    const sessionId = request.cookies[sessionService.sessionCookieName];

    // No cookie? Set null and continue
    if (!sessionId) {
      request.user = null;
      request.session = null;
      return;
    }

    // Validate session with Lucia
    const { session, user } = await sessionService.validate(sessionId);

    // Session is fresh (< 50% lifetime remaining)?
    // Lucia automatically extends it - set new cookie
    if (session?.fresh) {
      reply.setCookie(
        sessionService.sessionCookieName,
        session.id,
        sessionService.sessionCookieAttributes
      );
    }

    // Session expired/invalid? Clear cookie
    if (!session) {
      const blankCookie = sessionService.createBlankSessionCookie();
      reply.setCookie(
        blankCookie.name,
        blankCookie.value,
        blankCookie.attributes
      );
    }

    // Attach to request for route handlers
    request.user = user;
    request.session = session;
  });
};
```

### Update apps/api/src/server.ts

```typescript
// Add session middleware after request logger, before routes

import { sessionMiddleware } from "./middleware/session.middleware.js";

export async function createServer(): Promise<FastifyInstance> {
  const app = fastify({
    logger: false,
    requestIdHeader: "x-request-id",
    requestIdLogLabel: "requestId",
  });

  // Register CORS
  await app.register(cors, {
    origin: config.CORS_ORIGINS.split(",").map((s) => s.trim()),
    credentials: true,
    methods: ["GET", "POST", "PUT", "PATCH", "DELETE"],
  });

  // Register cookie parser (required for session middleware)
  await app.register(fastifyCookie);

  // Register request logger
  await app.register(requestLogger);

  // Register session middleware (NEW)
  await app.register(sessionMiddleware);

  // Register routes
  await app.register(healthRoutes);

  // Register error handler (must be last)
  app.setErrorHandler(errorHandler);

  return app;
}
```

### Authentication Helpers

```typescript
// apps/api/src/middleware/auth.middleware.ts [NEW FILE]

import { FastifyPluginAsync } from "fastify";
import { UnauthorizedError } from "@raptscallions/core/errors";

/**
 * Require authentication preHandler.
 * Throws UnauthorizedError if no user is attached to request.
 *
 * Usage:
 * ```typescript
 * app.get("/protected", {
 *   preHandler: [app.requireAuth]
 * }, handler);
 * ```
 */
export const authMiddleware: FastifyPluginAsync = async (app) => {
  app.decorate("requireAuth", async (request, reply) => {
    if (!request.user) {
      throw new UnauthorizedError("Authentication required");
    }
  });

  app.decorate("requireActiveUser", async (request, reply) => {
    if (!request.user) {
      throw new UnauthorizedError("Authentication required");
    }
    if (request.user.status !== "active") {
      throw new UnauthorizedError("Account is not active");
    }
  });
};

// Augment Fastify instance with auth decorators
declare module "fastify" {
  interface FastifyInstance {
    requireAuth: (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
    requireActiveUser: (request: FastifyRequest, reply: FastifyReply) => Promise<void>;
  }
}
```

---

## Testing Strategy

### Unit Tests: packages/auth/__tests__/session.service.test.ts

```typescript
import { describe, it, expect, vi, beforeEach } from "vitest";
import { SessionService } from "../src/session.service.js";
import { lucia } from "../src/lucia.js";

vi.mock("../src/lucia.js", () => ({
  lucia: {
    validateSession: vi.fn(),
    createSession: vi.fn(),
    invalidateSession: vi.fn(),
    invalidateUserSessions: vi.fn(),
    createBlankSessionCookie: vi.fn(),
    sessionCookieName: "auth_session",
    sessionCookie: {
      attributes: {
        secure: false,
        httpOnly: true,
        sameSite: "lax",
        path: "/",
      },
    },
  },
}));

describe("SessionService", () => {
  let service: SessionService;

  beforeEach(() => {
    service = new SessionService();
    vi.clearAllMocks();
  });

  describe("validate", () => {
    it("should return session and user when valid", async () => {
      // Arrange
      const mockSession = { id: "session-123", userId: "user-123", fresh: false, expiresAt: new Date() };
      const mockUser = { id: "user-123", email: "test@example.com", name: "Test" };
      vi.mocked(lucia.validateSession).mockResolvedValue({ session: mockSession, user: mockUser });

      // Act
      const result = await service.validate("session-123");

      // Assert
      expect(result.session).toEqual(mockSession);
      expect(result.user).toEqual(mockUser);
      expect(lucia.validateSession).toHaveBeenCalledWith("session-123");
    });

    it("should return null for expired session", async () => {
      // Arrange
      vi.mocked(lucia.validateSession).mockResolvedValue({ session: null, user: null });

      // Act
      const result = await service.validate("expired-session");

      // Assert
      expect(result.session).toBeNull();
      expect(result.user).toBeNull();
    });
  });

  describe("create", () => {
    it("should create new session", async () => {
      // Arrange
      const mockSession = { id: "new-session", userId: "user-123", fresh: true, expiresAt: new Date() };
      vi.mocked(lucia.createSession).mockResolvedValue(mockSession);

      // Act
      const result = await service.create("user-123");

      // Assert
      expect(result).toEqual(mockSession);
      expect(lucia.createSession).toHaveBeenCalledWith("user-123", {});
    });
  });

  describe("invalidate", () => {
    it("should invalidate session", async () => {
      // Arrange
      vi.mocked(lucia.invalidateSession).mockResolvedValue();

      // Act
      await service.invalidate("session-123");

      // Assert
      expect(lucia.invalidateSession).toHaveBeenCalledWith("session-123");
    });
  });
});
```

### Integration Tests: apps/api/src/__tests__/middleware/session.middleware.test.ts

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { createServer } from "../../server.js";
import type { FastifyInstance } from "fastify";
import { sessionService } from "@raptscallions/auth";

vi.mock("@raptscallions/auth");

describe("Session Middleware", () => {
  let app: FastifyInstance;

  beforeEach(async () => {
    app = await createServer();
    await app.ready();
  });

  afterEach(async () => {
    await app.close();
  });

  it("should attach null user when no session cookie", async () => {
    // Arrange
    app.get("/test", async (request, reply) => {
      return { user: request.user, session: request.session };
    });

    // Act
    const response = await app.inject({
      method: "GET",
      url: "/test",
    });

    // Assert
    expect(response.statusCode).toBe(200);
    const body = JSON.parse(response.body);
    expect(body.user).toBeNull();
    expect(body.session).toBeNull();
  });

  it("should attach user when valid session cookie", async () => {
    // Arrange
    const mockUser = { id: "user-123", email: "test@example.com", name: "Test" };
    const mockSession = { id: "session-123", userId: "user-123", fresh: false };
    vi.mocked(sessionService.validate).mockResolvedValue({
      session: mockSession,
      user: mockUser,
    });

    app.get("/test", async (request, reply) => {
      return { user: request.user };
    });

    // Act
    const response = await app.inject({
      method: "GET",
      url: "/test",
      cookies: { auth_session: "session-123" },
    });

    // Assert
    expect(response.statusCode).toBe(200);
    const body = JSON.parse(response.body);
    expect(body.user).toEqual(mockUser);
  });
});
```

---

## Implementation Checklist

### Database Changes

- [ ] Create `packages/db/src/schema/sessions.ts` with sessions table schema
- [ ] Add sessions relations for Drizzle query builder
- [ ] Export sessions from `packages/db/src/schema/index.ts`
- [ ] Create migration `0004_create_sessions.sql` (up)
- [ ] Create migration `0004_create_sessions.down.sql` (down)
- [ ] Run migration: `pnpm --filter @raptscallions/db db:generate`
- [ ] Test migration up: `pnpm --filter @raptscallions/db db:migrate`
- [ ] Test migration down and re-run up to verify reversibility

### Auth Package

- [ ] Create `packages/auth/` directory structure
- [ ] Create `packages/auth/package.json` with dependencies
- [ ] Create `packages/auth/tsconfig.json` extending root config
- [ ] Create `packages/auth/vitest.config.ts` extending root config
- [ ] Add `packages/auth` to `vitest.workspace.ts`
- [ ] Add path alias to root `tsconfig.json` and `vitest.config.ts`
- [ ] Install dependencies: `pnpm install`
- [ ] Create `packages/auth/src/lucia.ts` with Lucia configuration
- [ ] Create `packages/auth/src/types.ts` with type definitions
- [ ] Create `packages/auth/src/session.service.ts` with session operations
- [ ] Create `packages/auth/src/index.ts` with barrel exports
- [ ] Create unit tests for session service
- [ ] Run tests: `pnpm --filter @raptscallions/auth test`

### API Integration

- [ ] Add `@fastify/cookie` to `apps/api/package.json`
- [ ] Add `@raptscallions/auth` workspace dependency to `apps/api/package.json`
- [ ] Install dependencies: `pnpm install`
- [ ] Create `apps/api/src/types/fastify.d.ts` with type augmentation
- [ ] Create `apps/api/src/middleware/session.middleware.ts`
- [ ] Create `apps/api/src/middleware/auth.middleware.ts` with requireAuth
- [ ] Update `apps/api/src/server.ts` to register middlewares
- [ ] Create integration tests for session middleware
- [ ] Create integration tests for auth middleware
- [ ] Run tests: `pnpm --filter @raptscallions/api test`

### Verification

- [ ] Run typecheck: `pnpm typecheck` (MUST pass with zero errors)
- [ ] Run all tests: `pnpm test` (MUST pass)
- [ ] Test session creation manually with database inspection
- [ ] Test session validation with expired session
- [ ] Test session extension (fresh session)
- [ ] Test session invalidation
- [ ] Verify cookie is set correctly with proper attributes
- [ ] Verify cookie is cleared on logout

---

## Acceptance Criteria Mapping

| AC | Requirement | Implementation |
|----|-------------|----------------|
| AC1 | sessions table schema in packages/db/src/schema/sessions.ts | `packages/db/src/schema/sessions.ts` |
| AC2 | Fields: id, user_id, expires_at | Schema definition with correct types |
| AC3 | Foreign key with CASCADE delete | `references(() => users.id, { onDelete: 'cascade' })` |
| AC4 | Migration 0004_create_sessions.sql | Up and down migrations created and tested |
| AC5 | Lucia with DrizzlePostgreSQLAdapter | `packages/auth/src/lucia.ts` |
| AC6 | Session middleware validates and attaches user | `apps/api/src/middleware/session.middleware.ts` |
| AC7 | Session creation helper | `sessionService.create()` |
| AC8 | Session deletion helper | `sessionService.invalidate()` |
| AC9 | SessionUser type exported | `packages/auth/src/types.ts` |
| AC10 | Tests for session operations | Unit tests + integration tests |

---

## Security Considerations

1. **Session ID Generation**: Lucia uses cryptographically secure random generation for session IDs (40 characters)
2. **Cookie Security**:
   - httpOnly prevents JavaScript access (XSS protection)
   - secure flag in production (HTTPS only)
   - sameSite: lax prevents CSRF attacks
3. **Session Expiration**: 30-day expiration with automatic extension for active sessions
4. **Cascade Delete**: When a user is deleted, all sessions are automatically removed
5. **Password Changes**: Future implementation should invalidate all sessions on password change

---

## Performance Considerations

1. **Indexes**:
   - `sessions_user_id_idx` speeds up "get user sessions" queries
   - `sessions_expires_at_idx` speeds up cleanup of expired sessions
2. **Session Extension**: Lucia only extends sessions that are "fresh" (< 50% lifetime remaining) to reduce database writes
3. **Validation Performance**: Session validation is a single SELECT query with user join
4. **Connection Pooling**: Uses existing Drizzle connection pool (max 10 connections)

---

## Future Enhancements (Out of Scope)

- Redis-based session storage for horizontal scaling
- Session activity tracking (last accessed timestamp, IP address)
- Suspicious activity detection (multiple IPs, rapid location changes)
- Device fingerprinting and management
- "Remember me" functionality with longer-lived sessions

---

## Related Tasks

- **E02-T001**: Users table (COMPLETED) - Dependency
- **E02-T003**: Password authentication - Will use session creation
- **E02-T004**: OAuth providers - Will use session creation
- **E02-T005**: Login/logout routes - Will use session service

---

## References

- [Lucia Documentation](https://lucia-auth.com/)
- [Lucia Database Adapter](https://lucia-auth.com/database/)
- [Drizzle PostgreSQL Adapter](https://lucia-auth.com/database/drizzle)
- [Fastify Hooks](https://fastify.dev/docs/latest/Reference/Hooks/)
- [OWASP Session Management](https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html)

---

## UX Review

**Reviewer:** designer
**Date:** 2026-01-12
**Verdict:** NEEDS_UX_CHANGES

### Summary

This specification implements foundational session management infrastructure with solid technical patterns. However, it lacks critical UX considerations specific to K-12 education environments where shared devices, varying user sophistication levels, and classroom-specific security concerns are paramount. The current 30-day session lifetime and lack of "remember me" options do not adequately address the diverse needs of teachers vs. students, or distinguish between personal and shared device contexts.

---

## Critical Issues (Must Address Before Implementation)

### 1. Shared Device Context - No Mitigation

**Issue:** Education environments have unique device sharing patterns (computer labs, classroom carts, shared teacher workstations) where the 30-day auto-extending session creates serious security and privacy concerns.

**Example Scenario:**
- Student logs into computer lab, works for 20 minutes, closes browser
- Next student opens browser same day - still logged in as previous student
- Can access previous student's work, conversations with AI tutors, personal data

**Why It's Critical:**
The spec notes "School computer lab sessions - public/shared device considerations?" as a question but provides no answer. This is a blocker because the platform will be deployed in environments where this is the default use case, not an edge case.

**Required Changes:**
1. Add shorter idle timeout (separate from expiration) for inactivity detection
2. Implement session context flag: `is_shared_device: boolean` (default: false)
3. Shared device sessions should NOT auto-extend and should have much shorter lifetime (1-2 hours max)
4. Add user-facing "This is a shared computer" checkbox on login page
5. When shared device mode is active, show persistent banner: "You're on a shared computer - [Log Out]"

**Spec Update Needed:**
- Add `SessionContext` enum: `personal`, `shared`, `unknown`
- Add `context` field to sessions table
- Modify session middleware to respect context-based expiration
- Document UX requirements for login page checkbox

---

### 2. No Student vs. Teacher Session Differentiation

**Issue:** The spec treats all users identically for session management. Teachers and students have fundamentally different usage patterns and security needs.

**Teachers:**
- Need long sessions (work across multiple periods, days)
- Use personal devices more often
- Handle sensitive student data (FERPA concerns)
- Want "remember me" for convenience

**Students:**
- Often use shared devices
- Should have shorter sessions by default
- Less sophisticated about security implications
- May need forced logout at class/day end

**Why It's Critical:**
A single 30-day session policy doesn't serve either user group appropriately. Students on shared devices are under-protected; teachers on personal devices are inconvenienced.

**Required Changes:**
1. Add role-based session configuration:
   - Teachers: 30 days (as specified)
   - Students: 7 days on personal, 2 hours on shared
2. Add `user_role` to session validation context
3. Document future "remember me" scope (must be role-aware)

**Spec Update Needed:**
- Add session duration table by role and context
- Modify `lucia.ts` configuration to support role-based expiration
- Add acceptance criteria: "Session expiration varies by user role"

---

### 3. Session Expiration User Experience - Undefined

**Issue:** The spec details technical session expiration but provides no guidance on what users experience when their session expires.

**Current State:**
- Session expires silently
- Cookie cleared by middleware
- User sees... what? Redirect? Modal? Error?
- Data loss? (User typing message, session expires, submission fails?)

**Why It's Critical:**
Poor session expiration UX is one of the most frustrating experiences in web apps. Users lose work, get confused about why they're logged out, and abandon tasks.

**Required Changes:**
1. Define expiration warning system (15 minutes before expiry)
2. Specify modal/banner behavior: "Your session will expire in 15 minutes. [Stay Logged In] [Log Out]"
3. Handle in-flight requests gracefully (save draft before redirect)
4. Specify redirect behavior: "Your session has expired. Please log in again."
5. Preserve return URL for post-login redirect

**Spec Update Needed:**
- Add section: "Session Expiration UX Flow"
- Document frontend requirements (even though this is backend task)
- Add `last_activity_at` to sessions table for idle detection
- Create follow-up task for frontend implementation

---

## Recommendations (Should Address)

### 4. "Logout from All Devices" - No UI/UX Specification

**Issue:** The spec implements `invalidateUserSessions()` but doesn't address when/how users access this feature.

**Recommendation:**
Document the intended UX for session management:
- Where does this appear? (Account settings? Security tab?)
- What does the user see? ("You're logged in on 3 devices. Last active: 2 hours ago")
- Confirmation flow? ("This will log you out everywhere. Continue?")
- What about current session? (Stay logged in or force re-login?)

**Spec Update:**
Add note to "Future Enhancements" or create follow-up task: "Account security page with active sessions list"

---

### 5. Session Cookie Naming - Education Context

**Issue:** Cookie name `auth_session` is generic and doesn't indicate the application.

**Recommendation:**
Use `raptscallions_session` or `rapt_session` to:
- Avoid conflicts with other education platforms on same domain
- Make it clear in browser dev tools which app the cookie belongs to
- Help teachers/IT staff debugging issues

**Why This Matters:**
Teachers may use multiple ed-tech platforms. Clear naming reduces support burden.

**Spec Update:**
Change `sessionCookie.name` from `"auth_session"` to `"rapt_session"`

---

### 6. Error Messages - Not User-Friendly

**Issue:** Error messages are developer-focused, not user-focused:
- "Invalid session" - What does user do?
- "Session expired" - Why? What happened to their work?
- "Authentication required" - Too technical

**Recommendation:**
Create user-facing error messages in separate copy file:
```typescript
const USER_ERRORS = {
  SESSION_EXPIRED: "Your session has expired for security. Please log in again.",
  INVALID_SESSION: "We couldn't verify your login. Please log in again.",
  AUTH_REQUIRED: "Please log in to continue.",
  ACCOUNT_SUSPENDED: "Your account is not active. Contact your administrator.",
};
```

**Spec Update:**
Add section: "User-Facing Error Messages" with table of error codes and messages

---

## Suggestions (Optional Enhancements)

### 7. Session Activity Tracking

Add `last_activity_at` timestamp to sessions table for:
- Idle timeout detection (different from expiration)
- "Active sessions" UI showing last used time
- Analytics on session usage patterns

### 8. Remember Me Checkbox - Scope Now

While listed as "future enhancement," defining the scope now prevents re-architecture later:
- Where does state live? (Cookie? Session table field?)
- How does it interact with shared device mode? (Mutually exclusive?)
- What's the extended duration? (90 days? 1 year?)

### 9. Grade-Level Session Policies

Consider future: Elementary students may need different policies than high school students.

---

## Approved Aspects (Good UX Decisions)

1. **Automatic Session Extension**: The 50% lifetime threshold for "fresh" sessions is good UX - keeps active users logged in without annoying re-authentications.

2. **httpOnly + secure Cookies**: Excellent security posture that protects users without any friction.

3. **sameSite: lax**: Good balance - protects against CSRF while allowing normal navigation patterns.

4. **Cascade Delete**: When user is deleted, sessions are cleaned up automatically. Good data hygiene with no orphaned sessions.

5. **Session Middleware Design**: Attaching user/session to request is clean and predictable for developers.

6. **30-Day Baseline**: Reasonable for personal devices and teachers. Just needs context-awareness (see critical issues).

---

## Implementation Recommendations

### Required Before Coding

1. Add `context` field to sessions table schema:
   ```typescript
   context: varchar("context", { length: 20 }).notNull().default("unknown"),
   lastActivityAt: timestamp("last_activity_at", { withTimezone: true }).notNull(),
   ```

2. Update Lucia config to accept role-based expiration function:
   ```typescript
   sessionExpiresIn: (userRole, context) => {
     // Return appropriate duration
   }
   ```

3. Document session expiration UX flow (even if implementation is future task)

4. Add acceptance criteria:
   - Session duration varies by user role (teacher/student)
   - Session context (shared/personal) affects expiration
   - Expired sessions provide user-friendly error message

### Create Follow-Up Tasks

1. **E02-TXX**: Session expiration warning UI (frontend)
2. **E02-TXX**: Account security page with active sessions (frontend + API)
3. **E02-TXX**: "This is a shared computer" login option (frontend)

---

## Accessibility Notes (for Implementation Phase)

When implementing frontend components related to sessions:
- Session timeout warnings must be ARIA live regions
- Logout buttons must be keyboard accessible
- Error messages must be associated with form context (aria-describedby)
- "Stay logged in" checkbox must have clear label and keyboard support

---

## Verdict Reasoning

This specification is technically solid but needs UX considerations added before implementation begins. The education context creates unique requirements around shared devices, varying user sophistication, and role-based policies that are not addressed. The critical issues must be resolved because they affect the database schema (adding `context` and `lastActivityAt` fields) and Lucia configuration (role-based expiration logic).

**Recommended Path:**
1. Analyst updates spec to address critical issues #1, #2, #3
2. Add session context and activity tracking to schema
3. Document UX flows for session expiration (even if UI is built later)
4. Proceed to architect review with updated spec

The underlying technical approach (Lucia v3, Drizzle adapter, session middleware) is sound and approved. The issue is purely about adapting the implementation to the education platform's specific UX needs.

---

## Architecture Review

**Reviewer:** architect
**Date:** 2026-01-12
**Verdict:** NEEDS_REVISION

### Executive Summary

This specification is architecturally **SOUND** but requires **MINOR REVISIONS** to align with:
1. Project containerization requirements
2. Environment configuration patterns
3. Critical UX issues raised by the designer

The core technical approach (Lucia v3, Drizzle adapter, Fastify middleware) is excellent and follows all architectural standards. However, the spec must address the designer's critical concerns about session context (shared devices) and role-based expiration BEFORE implementation begins, as these affect the database schema.

---

### Critical Issues (Must Fix Before Implementation)

#### 1. Database Schema Missing Required Fields from UX Review

The designer identified that the sessions table needs additional fields for shared device context and activity tracking.

**Required Schema Additions:**
```typescript
context: varchar("context", { length: 20 }).notNull().default("unknown"),
lastActivityAt: timestamp("last_activity_at", { withTimezone: true }).notNull(),
```

**Action Required:**
- Add `context` field (enum: 'personal', 'shared', 'unknown')
- Add `lastActivityAt` timestamp for idle timeout detection
- Update migration SQL to include these fields
- Document context values and their behavior

#### 2. Role-Based Session Duration Not Architecturally Specified

The spec hardcodes 30-day expiration for all users, but teachers and students need different policies.

**Required Approach:**
```typescript
function getSessionDuration(userRole: string, context: string): number {
  if (context === 'shared') {
    return 1000 * 60 * 60 * 2; // 2 hours for shared devices
  }
  if (userRole === 'student') {
    return 1000 * 60 * 60 * 24 * 7; // 7 days for students
  }
  return 1000 * 60 * 60 * 24 * 30; // 30 days for teachers/admins
}
```

**Action Required:**
- Document session duration table by role and context
- Update `lucia.ts` to use role-based expiration logic
- Add acceptance criteria: "Session duration varies by user role and device context"
- Update tests to cover different duration scenarios

#### 3. Environment Configuration for Session Settings Missing

Per CONVENTIONS.md, all configuration should use validated environment variables. Session settings are currently hardcoded.

**Required Pattern:**
```typescript
// apps/api/src/config.ts
const envSchema = z.object({
  SESSION_COOKIE_NAME: z.string().default("rapt_session"),
  SESSION_MAX_AGE_DAYS: z.coerce.number().default(30),
  SESSION_SHARED_DEVICE_HOURS: z.coerce.number().default(2),
  SESSION_STUDENT_DAYS: z.coerce.number().default(7),
});
```

**Action Required:**
- Add session configuration to `apps/api/src/config.ts`
- Update `lucia.ts` to read from validated config
- Add environment variables to `.env.example`
- Document configuration in spec

---

### Architecture Alignment Issues (Should Fix)

#### 4. Fastify Type Augmentation Location Inconsistency

Type declarations should be centralized in dedicated types directory.

**Correct Pattern:**
```
apps/api/src/types/
├── fastify.d.ts        # FastifyRequest augmentation
└── fastify-plugins.d.ts # FastifyInstance decorator augmentations
```

#### 5. Error Handling Should Use Typed Errors Consistently

The `session.service.ts` throws generic `Error` instead of typed errors from `@raptscallions/core/errors`.

**Action Required:**
- Define session-specific error codes in `@raptscallions/core/errors`
- Update all error throws in `session.service.ts` to use typed errors
- Update tests to assert on specific error types

#### 6. Cookie Name Should Be `rapt_session`

Change from generic `auth_session` to project-specific `rapt_session` per designer recommendation.

---

### Approved Architectural Decisions

The following design choices are architecturally sound:
- ✅ Lucia v3 with Drizzle Adapter
- ✅ Session Middleware as Fastify Plugin
- ✅ Cookie Configuration (httpOnly, secure, sameSite)
- ✅ Cascade Delete on User Foreign Key
- ✅ Indexes on `user_id` and `expires_at`
- ✅ Session Service Abstraction
- ✅ Type Exports and Augmentation

---

### Recommendations

1. **Session Cleanup Job**: Add BullMQ job for cleaning expired sessions
2. **Session Extension Configuration**: Make 50% threshold configurable
3. **Missing Test Scenarios**: Add tests for session extension, concurrent validation, role-based expiration

---

### Containerization Compatibility

✅ Compatible once Critical Issue #3 (environment config) is addressed
- No host dependencies
- Stateless (all state in PostgreSQL)
- No file system dependencies

---

### Security Assessment

**Verdict:** Secure for MVP once UX critical issues addressed
- ✅ Secure cookie attributes
- ✅ Proper foreign key constraints
- ✅ No session fixation vulnerabilities
- ⚠️ Shared device security depends on implementing context field

---

### Approval Path

1. Analyst updates spec to address critical issues #1-3
2. Architect re-reviews updated spec
3. Designer confirms UX concerns addressed
4. Set task `workflow_state` to `APPROVED`
5. Proceed to implementation

---

### Collaboration Note

The designer's UX review correctly identified architectural requirements (not just UI concerns):
- Database schema changes (context, lastActivityAt fields)
- Business logic requirements (role-based expiration)
- System configuration needs (environment variables)

These must be addressed as architectural changes, not optional enhancements.

---

**END OF SPECIFICATION**
