---
id: "E05-T002"
title: "Storage backend abstraction and configuration"
status: "todo"
priority: "critical"
labels: [backend, infrastructure, architecture]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: []
blocks: ["E05-T003", "E05-T004", "E05-T005"]
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T002: Storage backend abstraction and configuration

## Description

Create `packages/storage` package with IStorageBackend interface, Zod configuration system following existing patterns, and storage factory for backend instantiation. This establishes the architecture for pluggable storage backends.

## Acceptance Criteria

### Package Structure
- [ ] AC1: Create `packages/storage` package with proper package.json and tsconfig
- [ ] AC2: Package name: @raptscallions/storage following monorepo conventions
- [ ] AC3: Dependencies: zod, @raptscallions/core, @raptscallions/db
- [ ] AC4: Barrel export file (packages/storage/src/index.ts)

### Storage Interface
- [ ] AC5: IStorageBackend interface with upload, download, delete, exists, getSignedUrl methods
- [ ] AC6: UploadParams interface (buffer, filename, mimeType, groupId)
- [ ] AC7: UploadResult interface (storageKey, sizeBytes)
- [ ] AC8: SignedUrl interface (url, expiresAt)
- [ ] AC9: TypeScript strict mode with zero errors

### Configuration System
- [ ] AC10: storageConfigSchema using Zod with STORAGE_BACKEND enum
- [ ] AC11: Backend enum: 'local', 's3', 'azure', 'gcs', 'aliyun'
- [ ] AC12: Proxy-based lazy config initialization (matching ai/config.ts pattern)
- [ ] AC13: Backend-specific config validation (refine method)
- [ ] AC14: Environment variable mapping for all backends
- [ ] AC15: Config export: storageConfig (lazy proxy), resetStorageConfig() for tests

### Storage Factory
- [ ] AC16: StorageFactory class with createBackend(backendType) method
- [ ] AC17: Factory throws error for unknown backend types
- [ ] AC18: Singleton pattern for backend instances

### Error Types
- [ ] AC19: StorageError extends AppError with 500 status
- [ ] AC20: QuotaExceededError extends AppError with 403 status
- [ ] AC21: FileNotFoundError extends AppError with 404 status
- [ ] AC22: InvalidFileTypeError extends AppError with 400 status

### Testing
- [ ] AC23: Tests verify config validation rejects invalid backends
- [ ] AC24: Tests verify factory creates correct backend instances
- [ ] AC25: Tests verify Proxy lazy initialization
- [ ] AC26: Tests verify error types have correct status codes

## Technical Notes

### IStorageBackend Interface

```typescript
// packages/storage/src/types.ts

export interface IStorageBackend {
  /**
   * Backend name for identification.
   */
  readonly name: string;

  /**
   * Upload a file to storage backend.
   * @returns Storage key (unique identifier for the file)
   */
  upload(params: UploadParams): Promise<UploadResult>;

  /**
   * Download a file from storage backend.
   * @param storageKey - Unique identifier returned from upload
   * @returns File buffer
   */
  download(storageKey: string): Promise<Buffer>;

  /**
   * Delete a file from storage backend.
   * @param storageKey - Unique identifier returned from upload
   */
  delete(storageKey: string): Promise<void>;

  /**
   * Check if file exists in storage backend.
   * @param storageKey - Unique identifier returned from upload
   */
  exists(storageKey: string): Promise<boolean>;

  /**
   * Generate signed URL for direct download.
   * @param storageKey - Unique identifier returned from upload
   * @param expiresIn - Expiration time in seconds (default: 900 = 15 min)
   * @returns Signed URL and expiration timestamp
   */
  getSignedUrl(storageKey: string, expiresIn?: number): Promise<SignedUrl>;
}

export interface UploadParams {
  buffer: Buffer;
  filename: string;
  mimeType: string;
  groupId?: string;
}

export interface UploadResult {
  storageKey: string;
  sizeBytes: number;
}

export interface SignedUrl {
  url: string;
  expiresAt: Date;
}
```

### Configuration Schema

```typescript
// packages/storage/src/config.ts

import { z } from 'zod';

export const storageBackendEnum = z.enum([
  'local',
  's3',
  'azure',
  'gcs',
  'aliyun',
]);

export type StorageBackend = z.infer<typeof storageBackendEnum>;

export const storageConfigSchema = z
  .object({
    // Global settings
    STORAGE_BACKEND: storageBackendEnum.default('s3'),
    DEFAULT_MAX_FILE_SIZE_BYTES: z.coerce.number().int().positive().default(10485760), // 10MB
    DEFAULT_STORAGE_QUOTA_BYTES: z.coerce.number().int().positive().default(1073741824), // 1GB
    SIGNED_URL_EXPIRES_SECONDS: z.coerce.number().int().positive().default(900), // 15 min

    // Local filesystem
    LOCAL_STORAGE_PATH: z.string().default('./storage/uploads'),

    // S3-compatible (AWS, MinIO, DigitalOcean Spaces, Backblaze B2)
    S3_ENDPOINT: z.string().url().optional(),
    S3_REGION: z.string().default('us-east-1'),
    S3_BUCKET: z.string().optional(),
    S3_ACCESS_KEY_ID: z.string().optional(),
    S3_SECRET_ACCESS_KEY: z.string().optional(),
    S3_FORCE_PATH_STYLE: z.coerce.boolean().default(false),

    // Azure Blob Storage
    AZURE_STORAGE_ACCOUNT: z.string().optional(),
    AZURE_STORAGE_ACCESS_KEY: z.string().optional(),
    AZURE_STORAGE_CONTAINER: z.string().optional(),

    // Google Cloud Storage
    GCS_BUCKET: z.string().optional(),
    GCS_PROJECT_ID: z.string().optional(),
    GCS_KEY_FILE: z.string().optional(),

    // Aliyun OSS
    ALIYUN_REGION: z.string().optional(),
    ALIYUN_BUCKET: z.string().optional(),
    ALIYUN_ACCESS_KEY_ID: z.string().optional(),
    ALIYUN_ACCESS_KEY_SECRET: z.string().optional(),
  })
  .refine(
    (data) => {
      // Validate backend-specific requirements
      if (data.STORAGE_BACKEND === 's3') {
        return !!(
          data.S3_BUCKET &&
          data.S3_ACCESS_KEY_ID &&
          data.S3_SECRET_ACCESS_KEY
        );
      }
      if (data.STORAGE_BACKEND === 'azure') {
        return !!(
          data.AZURE_STORAGE_ACCOUNT &&
          data.AZURE_STORAGE_ACCESS_KEY &&
          data.AZURE_STORAGE_CONTAINER
        );
      }
      if (data.STORAGE_BACKEND === 'gcs') {
        return !!(data.GCS_BUCKET && data.GCS_PROJECT_ID);
      }
      if (data.STORAGE_BACKEND === 'aliyun') {
        return !!(
          data.ALIYUN_BUCKET &&
          data.ALIYUN_ACCESS_KEY_ID &&
          data.ALIYUN_ACCESS_KEY_SECRET
        );
      }
      return true; // Local has no requirements
    },
    {
      message: 'Missing required configuration for selected storage backend',
    }
  );

export type StorageConfig = z.infer<typeof storageConfigSchema>;

/**
 * Lazy-loaded config instance (matches ai/config.ts pattern).
 */
let configInstance: StorageConfig | undefined;

function loadConfig(): StorageConfig {
  if (!configInstance) {
    configInstance = storageConfigSchema.parse({
      STORAGE_BACKEND: process.env.STORAGE_BACKEND,
      DEFAULT_MAX_FILE_SIZE_BYTES: process.env.DEFAULT_MAX_FILE_SIZE_BYTES,
      DEFAULT_STORAGE_QUOTA_BYTES: process.env.DEFAULT_STORAGE_QUOTA_BYTES,
      SIGNED_URL_EXPIRES_SECONDS: process.env.SIGNED_URL_EXPIRES_SECONDS,
      LOCAL_STORAGE_PATH: process.env.LOCAL_STORAGE_PATH,
      S3_ENDPOINT: process.env.S3_ENDPOINT,
      S3_REGION: process.env.S3_REGION,
      S3_BUCKET: process.env.S3_BUCKET,
      S3_ACCESS_KEY_ID: process.env.S3_ACCESS_KEY_ID,
      S3_SECRET_ACCESS_KEY: process.env.S3_SECRET_ACCESS_KEY,
      S3_FORCE_PATH_STYLE: process.env.S3_FORCE_PATH_STYLE,
      AZURE_STORAGE_ACCOUNT: process.env.AZURE_STORAGE_ACCOUNT,
      AZURE_STORAGE_ACCESS_KEY: process.env.AZURE_STORAGE_ACCESS_KEY,
      AZURE_STORAGE_CONTAINER: process.env.AZURE_STORAGE_CONTAINER,
      GCS_BUCKET: process.env.GCS_BUCKET,
      GCS_PROJECT_ID: process.env.GCS_PROJECT_ID,
      GCS_KEY_FILE: process.env.GCS_KEY_FILE,
      ALIYUN_REGION: process.env.ALIYUN_REGION,
      ALIYUN_BUCKET: process.env.ALIYUN_BUCKET,
      ALIYUN_ACCESS_KEY_ID: process.env.ALIYUN_ACCESS_KEY_ID,
      ALIYUN_ACCESS_KEY_SECRET: process.env.ALIYUN_ACCESS_KEY_SECRET,
    });
  }
  return configInstance;
}

export function resetStorageConfig(): void {
  configInstance = undefined;
}

/**
 * Exported config with Proxy (lazy initialization).
 */
export const storageConfig = new Proxy({} as StorageConfig, {
  get(_target, prop: keyof StorageConfig) {
    const config = loadConfig();
    return config[prop];
  },
});
```

### Storage Factory

```typescript
// packages/storage/src/factory.ts

import type { IStorageBackend } from './types.js';
import type { StorageBackend } from './config.js';

/**
 * Storage factory for creating backend instances.
 * Uses lazy singleton pattern - backends created on first access.
 */
export class StorageFactory {
  private static instances = new Map<StorageBackend, IStorageBackend>();

  /**
   * Create or retrieve storage backend instance.
   * @param backendType - Backend type from config
   * @returns Storage backend instance
   */
  static createBackend(backendType: StorageBackend): IStorageBackend {
    // Check cache first
    if (this.instances.has(backendType)) {
      return this.instances.get(backendType)!;
    }

    // Create new instance
    let backend: IStorageBackend;

    switch (backendType) {
      case 'local':
        const { LocalStorageBackend } = await import('./backends/local.backend.js');
        backend = new LocalStorageBackend();
        break;
      case 's3':
        const { S3StorageBackend } = await import('./backends/s3.backend.js');
        backend = new S3StorageBackend();
        break;
      case 'azure':
        const { AzureStorageBackend } = await import('./backends/azure.backend.js');
        backend = new AzureStorageBackend();
        break;
      case 'gcs':
        const { GcsStorageBackend } = await import('./backends/gcs.backend.js');
        backend = new GcsStorageBackend();
        break;
      case 'aliyun':
        const { AliyunStorageBackend } = await import('./backends/aliyun.backend.js');
        backend = new AliyunStorageBackend();
        break;
      default:
        throw new Error(`Unknown storage backend: ${backendType}`);
    }

    // Cache instance
    this.instances.set(backendType, backend);
    return backend;
  }

  /**
   * Clear cached instances (for testing).
   */
  static reset(): void {
    this.instances.clear();
  }
}
```

### Error Types

```typescript
// packages/storage/src/errors.ts

import { AppError } from '@raptscallions/core';

export class StorageError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 'STORAGE_ERROR', 500, details);
  }
}

export class QuotaExceededError extends AppError {
  constructor(message: string, details?: unknown) {
    super(message, 'QUOTA_EXCEEDED', 403, details);
  }
}

export class FileNotFoundError extends AppError {
  constructor(fileId: string) {
    super(`File not found: ${fileId}`, 'FILE_NOT_FOUND', 404, { fileId });
  }
}

export class InvalidFileTypeError extends AppError {
  constructor(mimeType: string, allowed: string[]) {
    super(
      `Invalid file type: ${mimeType}. Allowed: ${allowed.join(', ')}`,
      'INVALID_FILE_TYPE',
      400,
      { mimeType, allowed }
    );
  }
}
```

## Out of Scope

- Actual backend implementations (E05-T003, E05-T004, E05-T005)
- File service logic (E05-T006)
- API routes (E05-T007, E05-T008)
- Database integration (E05-T001)

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
