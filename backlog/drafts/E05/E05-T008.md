---
id: "E05-T008"
title: "File download and limit management API routes"
status: "todo"
priority: "high"
labels: [backend, api, admin]
assignee: ""
workflow_state: "DRAFT"
epic: "E05"
depends_on: ["E05-T006"]
blocks: []
breakpoint: false
assigned_agent: ""
created_at: "2026-01-13T00:00:00Z"
updated_at: "2026-01-13T00:00:00Z"
spec_file: ""
test_files: []
code_files: []
pr_url: ""
---

# E05-T008: File download and limit management API routes

## Description

Implement file download, deletion, listing, quota查询 routes, and admin routes for managing user-specific limit overrides and group role-based limits.

## Acceptance Criteria

### User-Facing File Routes
- [ ] AC1: GET /files/:id returns file metadata + signed download URL
- [ ] AC2: DELETE /files/:id soft deletes file (owner or admin)
- [ ] AC3: GET /files lists user's files with pagination (cursor-based)
- [ ] AC4: GET /files supports filters: entityType, entityId, groupId, status
- [ ] AC5: GET /users/me/quota returns storage usage, limit, and source
- [ ] AC6: GET /users/me/limits returns effective limits with source
- [ ] AC7: All routes require authentication (app.authenticate)
- [ ] AC8: CASL permissions enforced on all operations

### Admin Limit Management Routes
- [ ] AC9: PATCH /admin/users/:userId/limits sets user-specific overrides
- [ ] AC10: DELETE /admin/users/:userId/limits clears user overrides
- [ ] AC11: GET /admin/users/:userId/limits returns user's effective limits + override details
- [ ] AC12: PATCH /admin/groups/:groupId/limits sets role-based limits
- [ ] AC13: Admin routes require system_admin role (app.requireRole preHandler)
- [ ] AC14: Request body validation with Zod schemas

### Response Formats
- [ ] AC15: GET /files/:id returns: { data: { ...file, signedUrl, expiresAt } }
- [ ] AC16: GET /files returns: { data: [...files], meta: { nextCursor, hasMore } }
- [ ] AC17: GET /users/me/quota returns: { data: { usedBytes, quotaBytes, remainingBytes, source } }
- [ ] AC18: 404 if file not found or soft deleted
- [ ] AC19: 403 if user lacks permission

### Testing
- [ ] AC20: Tests verify file download with signed URL
- [ ] AC21: Tests verify file deletion updates quota
- [ ] AC22: Tests verify pagination works correctly
- [ ] AC23: Tests verify filters (entityType, groupId)
- [ ] AC24: Tests verify admin can set user overrides
- [ ] AC25: Tests verify non-admin cannot set overrides
- [ ] AC26: Tests verify limit source is correctly returned

## Technical Notes

### User-Facing Routes

```typescript
// apps/api/src/routes/files.routes.ts (continued)

/**
 * GET /files/:id
 * Get file metadata and signed download URL
 */
typedApp.get<{ Params: { id: string } }>(
  '/:id',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
    },
  },
  async (request, reply) => {
    const file = await fileService.getFile(request.params.id, request.ability);

    return reply.send({
      data: {
        id: file.id,
        name: file.name,
        mimeType: file.mimeType,
        sizeBytes: file.sizeBytes,
        signedUrl: file.signedUrl,
        entityType: file.entityType,
        entityId: file.entityId,
        createdAt: file.createdAt,
      },
    });
  }
);

/**
 * DELETE /files/:id
 * Soft delete file
 */
typedApp.delete<{ Params: { id: string } }>(
  '/:id',
  {
    preHandler: [app.authenticate],
    schema: {
      params: z.object({ id: z.string().uuid() }),
    },
  },
  async (request, reply) => {
    await fileService.softDeleteFile(request.params.id, request.ability);
    return reply.status(204).send();
  }
);

/**
 * GET /files
 * List user's files with filters and pagination
 */
typedApp.get<{
  Querystring: {
    cursor?: string;
    limit?: number;
    entityType?: string;
    entityId?: string;
    groupId?: string;
    status?: string;
  };
}>(
  '/',
  {
    preHandler: [app.authenticate],
    schema: {
      querystring: z.object({
        cursor: z.string().uuid().optional(),
        limit: z.coerce.number().int().min(1).max(100).default(50),
        entityType: z.string().optional(),
        entityId: z.string().uuid().optional(),
        groupId: z.string().uuid().optional(),
        status: z.enum(['active', 'soft_deleted']).default('active'),
      }),
    },
  },
  async (request, reply) => {
    const { files, nextCursor } = await fileService.listFiles(
      request.user!.id,
      request.query,
      request.ability
    );

    return reply.send({
      data: files,
      meta: {
        pagination: {
          nextCursor,
          hasMore: !!nextCursor,
        },
      },
    });
  }
);

/**
 * GET /users/me/quota
 * Get current user's storage quota
 */
typedApp.get(
  '/users/me/quota',
  { preHandler: [app.authenticate] },
  async (request, reply) => {
    const limits = await fileLimitsService.getEffectiveLimits(request.user!.id);

    return reply.send({
      data: {
        usedBytes: limits.usedBytes,
        quotaBytes: limits.storageQuotaBytes,
        remainingBytes: Math.max(0, limits.storageQuotaBytes - limits.usedBytes),
        source: limits.source,
      },
    });
  }
);

/**
 * GET /users/me/limits
 * Get current user's effective limits
 */
typedApp.get(
  '/users/me/limits',
  { preHandler: [app.authenticate] },
  async (request, reply) => {
    const limits = await fileLimitsService.getEffectiveLimits(request.user!.id);

    return reply.send({
      data: {
        maxFileSizeBytes: limits.maxFileSizeBytes,
        storageQuotaBytes: limits.storageQuotaBytes,
        usedBytes: limits.usedBytes,
        source: limits.source,
      },
    });
  }
);
```

### Admin Limit Management Routes

```typescript
// apps/api/src/routes/admin/limits.routes.ts

import type { FastifyPluginAsync } from 'fastify';
import { z } from 'zod';
import { FileLimitsService } from '../../services/file-limits.service.js';

const fileLimitsService = new FileLimitsService();

const setUserLimitsSchema = z.object({
  maxFileSizeBytes: z.number().int().positive().optional(),
  storageQuotaBytes: z.number().int().positive().optional(),
  reason: z.string().optional(),
});

const setGroupLimitsSchema = z.object({
  teacher: z.object({
    maxFileSizeBytes: z.number().int().positive().optional(),
    storageQuotaBytes: z.number().int().positive().optional(),
  }).optional(),
  student: z.object({
    maxFileSizeBytes: z.number().int().positive().optional(),
    storageQuotaBytes: z.number().int().positive().optional(),
  }).optional(),
});

export const adminLimitsRoutes: FastifyPluginAsync = async (app) => {
  /**
   * PATCH /admin/users/:userId/limits
   * Set user-specific limit overrides (system_admin only)
   */
  app.patch<{
    Params: { userId: string };
    Body: z.infer<typeof setUserLimitsSchema>;
  }>(
    '/users/:userId/limits',
    {
      preHandler: [app.authenticate, app.requireRole('system_admin')],
      schema: {
        params: z.object({ userId: z.string().uuid() }),
        body: setUserLimitsSchema,
      },
    },
    async (request, reply) => {
      await fileLimitsService.setUserOverride(
        request.params.userId,
        {
          maxFileSizeBytes: request.body.maxFileSizeBytes,
          storageQuotaBytes: request.body.storageQuotaBytes,
        },
        request.user!.id,
        request.body.reason
      );

      return reply.status(204).send();
    }
  );

  /**
   * DELETE /admin/users/:userId/limits
   * Clear user-specific limit overrides
   */
  app.delete<{ Params: { userId: string } }>(
    '/users/:userId/limits',
    {
      preHandler: [app.authenticate, app.requireRole('system_admin')],
      schema: {
        params: z.object({ userId: z.string().uuid() }),
      },
    },
    async (request, reply) => {
      await fileLimitsService.clearUserOverride(request.params.userId);
      return reply.status(204).send();
    }
  );

  /**
   * GET /admin/users/:userId/limits
   * Get user's effective limits and override details
   */
  app.get<{ Params: { userId: string } }>(
    '/users/:userId/limits',
    {
      preHandler: [app.authenticate, app.requireRole('system_admin')],
      schema: {
        params: z.object({ userId: z.string().uuid() }),
      },
    },
    async (request, reply) => {
      const limits = await fileLimitsService.getEffectiveLimits(request.params.userId);
      const override = await fileLimitsService.getUserOverride(request.params.userId);

      return reply.send({
        data: {
          effective: limits,
          override: override || null,
        },
      });
    }
  );

  /**
   * PATCH /admin/groups/:groupId/limits
   * Set role-based limits for a group
   */
  app.patch<{
    Params: { groupId: string };
    Body: z.infer<typeof setGroupLimitsSchema>;
  }>(
    '/groups/:groupId/limits',
    {
      preHandler: [app.authenticate, app.requirePermission('manage', 'Group')],
      schema: {
        params: z.object({ groupId: z.string().uuid() }),
        body: setGroupLimitsSchema,
      },
    },
    async (request, reply) => {
      await groupService.updateSettings(request.params.groupId, {
        limits: request.body,
      });

      return reply.status(204).send();
    }
  );
};
```

### Route Registration

```typescript
// apps/api/src/server.ts

export async function createServer() {
  const app = fastify({ /* ... */ });

  // ... other setup

  // Register routes
  await app.register(filesRoutes, { prefix: '/files' });
  await app.register(adminLimitsRoutes, { prefix: '/admin' });

  return app;
}
```

### Integration Test Examples

```typescript
// apps/api/src/__tests__/routes/admin/limits.routes.test.ts

describe('Admin Limit Management', () => {
  it('should allow admin to set user override', async () => {
    const response = await app.inject({
      method: 'PATCH',
      url: `/admin/users/${userId}/limits`,
      headers: { authorization: `Bearer ${adminToken}` },
      payload: {
        maxFileSizeBytes: 100 * MB,
        storageQuotaBytes: 10 * GB,
        reason: 'Graduate student research project',
      },
    });

    expect(response.statusCode).toBe(204);

    // Verify override was applied
    const limits = await fileLimitsService.getEffectiveLimits(userId);
    expect(limits.maxFileSizeBytes).toBe(100 * MB);
    expect(limits.source).toBe('user_override');
  });

  it('should forbid non-admin from setting user override', async () => {
    const response = await app.inject({
      method: 'PATCH',
      url: `/admin/users/${userId}/limits`,
      headers: { authorization: `Bearer ${teacherToken}` },
      payload: {
        maxFileSizeBytes: 100 * MB,
      },
    });

    expect(response.statusCode).toBe(403);
  });

  it('should allow group admin to set role limits', async () => {
    const response = await app.inject({
      method: 'PATCH',
      url: `/admin/groups/${groupId}/limits`,
      headers: { authorization: `Bearer ${groupAdminToken}` },
      payload: {
        teacher: {
          maxFileSizeBytes: 50 * MB,
          storageQuotaBytes: 5 * GB,
        },
        student: {
          maxFileSizeBytes: 10 * MB,
          storageQuotaBytes: 1 * GB,
        },
      },
    });

    expect(response.statusCode).toBe(204);
  });
});
```

## Out of Scope

- Frontend UI for limit management (E06)
- Bulk limit updates
- Limit history/audit log viewing
- File preview/thumbnail generation
- Batch file operations

## History

| Date | State | Agent | Notes |
| ---- | ----- | ----- | ----- |
| 2026-01-13 | DRAFT | pm | Task created for Epic E05 |
